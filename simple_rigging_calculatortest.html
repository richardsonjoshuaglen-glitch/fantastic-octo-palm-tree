<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Simple COG Rigging Calculator</title>
<style>
  :root{
  --bg:#ffffff; --ink:#111; --panel:#f6f8fa; --border:#e9ecef; --accent:#0d6efd;
  --pickL:#ffd60a; --pickR:#32cd32; --roll:#5bc0ff;
  /* optional distinct colors for the 4-pick dots */
  --pX1:#ff6b6b; --pX2:#d63384; --pS1:#1abc9c; --pS2:#16a085;
}

  
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:16px; color:var(--ink); background:var(--bg); }
  h1 { font-size:20px; margin:0 0 10px; display:flex; align-items:center; gap:10px;}
  .badge{display:inline-block; padding:2px 8px; border-radius:999px; background:#d1e7dd; color:#0f5132; font-weight:700; font-size:12px;}
  fieldset { border:1px solid #ccc; border-radius:10px; margin:10px 0; padding:10px 12px; }
  legend { padding:0 6px; font-weight:600; }
  label { display:block; margin:6px 0 2px; font-size:14px; }
  select, input[type="number"] { width:100%; font-size:16px; padding:10px 12px; box-sizing:border-box; border-radius:8px; border:1px solid #cfd4d9; }
  .row { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
  .row3 { display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px; }
  .btn { display:inline-block; padding:10px 12px; margin:8px 6px 0 0; border-radius:10px; background:var(--accent); color:#fff; border:none; font-size:16px; cursor:pointer;}
  .btn.secondary{ background:#6c757d; }
  .items{ margin-top:6px;}
  .item{ padding:8px; border:1px dashed #999; border-radius:8px; margin-bottom:8px; font-size:14px;}
  .out{ background:var(--panel); padding:12px; border-radius:10px; border:1px solid var(--border); line-height:1.5; font-size:15px;}
  .out h3{ margin:6px 0; font-size:16px;}
  .pill{ display:inline-block; padding:2px 8px; border-radius:999px; font-weight:600; font-size:12px; color:#000;}
  .pill.left{ background:var(--pickL); } .pill.right{ background:var(--pickR); } .pill.roll{ background:var(--roll); }
  .muted{ color:#555; font-size:12px; }
  #sheet{ width:100%; max-width:1000px; background:#fff; border:1px solid #ddd; border-radius:8px; display:block;}
  #debug{ margin-top:6px; font-size:12px; color:#b00020; white-space:pre-wrap; border:1px dashed #ddd; padding:6px; border-radius:6px;}
  .bigcall { font-size:18px; font-weight:800; padding:8px 10px; border-radius:10px; background:#fff3cd; border:1px solid #ffe69c; display:inline-block; }
</style>
</head>
<body>
<h1>Rigging CG Helper — 2–4 Pick <span class="badge" id="badge">Ready</span></h1>

<!-- OUTPUT FIRST -->
<fieldset>
  <legend>Output (quick)</legend>
  <div id="summary" class="out">Add items and click “Compute + Draw”.</div>
  <div class="muted">Legend: <span class="pill left">Left pick</span> <span class="pill right">Right pick</span> · “Left Edge” = minimum coordinate on the chosen axis for that pick.</div>
</fieldset>

<!-- PICK SETUP -->
<fieldset>
  <legend>Pick setup (2 picks, spacing is fluid)</legend>
  <div class="row">
    <label>Left pick axis
      <select id="axisL">
        <option value="AUTO" selected>Auto (largest span)</option>
        <option value="X">X — Left → Right</option>
        <option value="Y">Y — Toward / Away</option>
        <option value="Z">Z — Up / Down</option>
      </select>
    </label>
    <label>Right pick axis
      <select id="axisR">
        <option value="AUTO" selected>Auto (largest span)</option>
        <option value="X">X — Left → Right</option>
        <option value="Y">Y — Toward / Away</option>
        <option value="Z">Z — Up / Down</option>
      </select>
    </label>
  </div>

  <div class="row">
  <label>Second axis for extra pair
    <select id="axisSecond">
      <option value="AUTO" selected>Auto (Y if span ≥ 12″, else Z if span ≥ 12″, else NONE)</option>
      <option value="Y">Force Y</option>
      <option value="Z">Force Z</option>
      <option value="NONE">None (4 on X)</option>
    </select>
  </label>
  <label>Minimum pair offset from CG (in)
    <input id="minPairOffset" type="number" inputmode="decimal" value="12">
  </label>
</div>
<div class="muted">4-pick mode: always two picks on X; second pair goes to the selected axis. If the chosen axis span &lt; 12″, we collapse to a single pick on that axis (3-pick total). If you select NONE, all 4 picks are on X (for long straight runs).</div>

  <div class="row">
    <label>Nominal pick spacing (in, fluid – CG & axes take precedence)
      <input id="pickSpacing" type="number" inputmode="decimal" value="72">
    </label>
    <label>Coupling avoidance (in) — keep picks ≥ this from couplings
      <input id="couplingClear" type="number" inputmode="decimal" value="2">
    </label>
  </div>
  <div class="row">
    <label>Pipe OD (for roll info; in)
      <input id="pipeOD" type="number" inputmode="decimal" value="24">
    </label>
    <div></div>
  </div>
  <div class="muted">Avoids <b>couplings</b> only (explicit and at <i>every joint</i>) by the chosen clearance. Picks are placed about CG and nudged to clear couplings; spacing is adjusted as needed.</div>
</fieldset>

<!-- ROLL HELPER -->
<fieldset>
  <legend>Roll helper (operator-proof)</legend>
  <div class="row">
    <label>Target roll to set on the pipe (degrees)
      <input id="targetRoll" type="number" inputmode="decimal" value="0">
      <div class="muted">Positive = roll the pipe toward +Y (toward you). Negative = roll toward −Y (away).</div>
    </label>
    <div>
      <button id="btnPlumb45" class="btn secondary" type="button">Set 45° for “plumb the 45° elbow face”</button>
      <div class="muted">Use when you have a 90° turning X+ → Y− and a 45° in Y− whose face must be plumb. This sets +45°.</div>
    </div>
  </div>
  <div class="muted">Note: The “CG roll” below is informational (from CG offset on a round). The “Target roll” above is what you actually tell the operator to set on the pipe.</div>
</fieldset>

<!-- ADD ITEMS -->
<fieldset>
  <legend>Add item</legend>
  <div class="row">
    <label>Item type
      <select id="itemType">
        <option value="P">24″ pipe (per-inch)</option>
        <option value="V">24″ valve (regular)</option>
        <option value="C">24″ coupling (weight only)</option>
        <option value="E">24″ 90° elbow</option>
        <option value="F">24″ 45° elbow</option>
        <option value="T">24″ tee (plain)</option>
        <option value="W">24″ tee with valve</option>
        <option value="X">Custom per-inch</option>
        <option value="Y">Custom fixed</option>
      </select>
    </label>
    <label>Orientation (axis + layman direction)
      <select id="orient">
        <option value="A" selected>A — X+ (Left → Right)</option>
        <option value="B">B — X− (Right → Left)</option>
        <option value="C">C — Y+ (Toward)</option>
        <option value="D">D — Y− (Away)</option>
        <option value="E">E — Z+ (Up)</option>
        <option value="F">F — Z− (Down)</option>
      </select>
    </label>
    <label id="turnRow" style="display:none">Turn to (2nd axis for elbow/tee)
      <select id="turnTo">
  <option value="NONE" selected>None</option>
  <option value="X+">X+ (Left → Right)</option>
  <option value="X-">X− (Right → Left)</option>
  <option value="Y+">Y+ (Toward)</option>
  <option value="Y-">Y− (Away)</option>
  <option value="Z+">Z+ (Up)</option>
  <option value="Z-">Z− (Down)</option>
</select>

    </label>
  </div>
  <div class="row" id="lenRow">
    <label>Length (in)
      <input id="lenIn" type="number" inputmode="decimal" value="60">
    </label>
    <label id="wpiLabel">Weight per inch (lb/in)
      <input id="wpi" type="number" inputmode="decimal" value="8.2">
    </label>
  </div>
  <div class="row" id="fixedRow" style="display:none">
    <label>Total weight (lb)
      <input id="fixedW" type="number" inputmode="decimal" value="0">
    </label>
    <label>Effective length along chosen axis (in)
      <input id="fixedL" type="number" inputmode="decimal" value="0">
    </label>
  </div>

  <button class="btn" id="addBtn" type="button">Add item</button>
  <button class="btn secondary" id="clearBtn" type="button">Clear list</button>
<button class="btn danger" id="delLastBtn" type="button" style="background:#dc3545">Delete last item</button>
  
  <div class="items" id="items"></div>
  <div id="debug">debug: ready</div>
</fieldset>

<button class="btn" id="computeBtn" type="button">Compute + Draw</button>
<button class="btn secondary" id="downloadBtn" type="button" disabled>Download PNG</button>

<!-- DRAWINGS -->
<fieldset>
  <legend>Drawings</legend>
  <canvas id="sheet"></canvas>
  <div class="muted">Plan (X–Y) and Elevation (X–Z). Each pick is shown on the zero line of <i>its own</i> axis.</div>
</fieldset>

<script>
/* ---------- setup ---------- */
(function(){ const b=document.getElementById('badge'); if(b) b.textContent='Ready'; })();
function el(id){ return document.getElementById(id); }
function setupCanvas(canvas, cssW, cssH){
  cssW=cssW||1000; cssH=cssH||1000;
  const dpr=window.devicePixelRatio||1;
  canvas.style.width=cssW+'px'; canvas.style.height=cssH+'px';
  canvas.width=Math.floor(cssW*dpr); canvas.height=Math.floor(cssH*dpr);
  const ctx=canvas.getContext('2d'); ctx.setTransform(dpr,0,0,dpr,0,0); ctx.textBaseline='top'; return ctx;
}
const sheet=el('sheet'); let ctx=setupCanvas(sheet);

/* ---------- constants ---------- */
const W_PER_IN_DEFAULT=8.2;
const W_EL90=475.0, S_EL90=36.0;
const W_EL45=240.0, S_EL45=15.0;
const W_COUP=115.0;
const W_VALVE_BODY=451.0, L_VALVE_STD=12.0;
const W_TEE_BODY=477.0, L_TEE=20.0;

const COLORS={
  axisX:'#d12222', axisY:'#2a9d2a', axisZ:'#1f6feb',
  P:'#666666', E:'#2aa198', F:'#2aa198', V:'#ff9100', C:'#8e44ad', T:'#d33682', W:'#d33682', X:'#8d6e63', Y:'#8d6e63',
  pickLeft:getComputedStyle(document.documentElement).getPropertyValue('--pickL')||'#ffd60a',
  pickRight:getComputedStyle(document.documentElement).getPropertyValue('--pickR')||'#32cd32',
  pipeBand:'rgba(100,100,100,0.18)', centerline:'#000', roll:'#5bc0ff',
  pX1: getComputedStyle(document.documentElement).getPropertyValue('--pX1') || '#ff6b6b',
pX2: getComputedStyle(document.documentElement).getPropertyValue('--pX2') || '#d63384',
pS1: getComputedStyle(document.documentElement).getPropertyValue('--pS1') || '#1abc9c',
pS2: getComputedStyle(document.documentElement).getPropertyValue('--pS2') || '#16a085',

};
const ORIENTS={ A:[ 1,0,0], B:[-1,0,0], C:[ 0,1,0], D:[ 0,-1,0], E:[ 0,0,1], F:[ 0,0,-1] };

/* ---------- helpers ---------- */
function dirLayman(ax){
  switch(ax){
    case 'X+': return '(Left → Right)';
    case 'X-': return '(Right → Left)';
    case 'Y+': return '(Toward)';
    case 'Y-': return '(Away)';
    case 'Z+': return '(Up)';
    case 'Z-': return '(Down)';
    default: return '';
  }
}

function axisLabel(v){
  if(v[0]===1) return 'X+';
  if(v[0]===-1) return 'X-';
  if(v[1]===1) return 'Y+';
  if(v[1]===-1) return 'Y-';
  if(v[2]===1) return 'Z+';
  if(v[2]===-1) return 'Z-';
  return '?';
}

function r4(x){ return Math.round(x*4)/4; }
function r8(x){ return Math.round(x*8)/8; }
function fmtFtIn(x){
  const v=r4(x), ft=Math.floor(v/12), rem=v-ft*12;
  const whole=Math.floor(rem), frac=Math.round((rem-whole)*100)/100;
  const map={"0":"", "0.25":"-1/4", "0.5":"-1/2", "0.75":"-3/4"};
  const tag=(map.hasOwnProperty(String(frac))?map[String(frac)]:null);
  const inch=(tag!==null)? (whole+tag+'"') : (rem.toFixed(2)+'"');
  return ft? (ft+"' "+inch) : inch;
}
function fmtInchesQ(x){
  const v = r4(Math.max(0, x));
  const whole = Math.floor(v + 1e-9);
  const frac = v - whole;
  let tag = '';
  if (Math.abs(frac - 0.25) < 1e-9) tag = '-1/4';
  else if (Math.abs(frac - 0.5) < 1e-9) tag = '-1/2';
  else if (Math.abs(frac - 0.75) < 1e-9) tag = '-3/4';
  return whole + (tag || (frac ? ('-'+Math.round(frac*100)/100) : '')) + ' inches';
}
function edgeName(axis){
  if(axis==='X') return '(Xmin) left edge';
  if(axis==='Y') return '(Ymin) closest edge';
  return '(Zmin) bottom edge';
}
function addV(a,b){ return [a[0]+b[0],a[1]+b[1],a[2]+b[2]]; }
function mulV(a,k){ return [a[0]*k,a[1]*k,a[2]*k]; }
function mid3(a,b){ return [(a[0]+b[0])/2,(a[1]+b[1])/2,(a[2]+b[2])/2]; }

/* map "+/- axis" to unit vectors */
const AXDIR = {
  'X+':[1,0,0], 'X-':[-1,0,0],
  'Y+':[0,1,0], 'Y-':[0,-1,0],
  'Z+':[0,0,1], 'Z-':[0,0,-1],
};
function sameOrtho(a,b){
  // true if a and b are orthogonal and non-zero
  return (a[0]*b[0]+a[1]*b[1]+a[2]*b[2])===0 && (a.some(v=>v!==0)) && (b.some(v=>v!==0));
}
  /* ---------- station model (S along the polyline) ---------- */
// Build cumulative stationing along the sequential segments the user built.
function buildStationModel(){
  const Ssegs = []; // {s0, s1, len, dir:[x,y,z], start:[...], end:[...]}
  let acc = 0;
  for(const seg of segments){
    const dx = seg.end[0]-seg.start[0], dy = seg.end[1]-seg.start[1], dz = seg.end[2]-seg.start[2];
    const len = Math.hypot(dx, dy, dz);
    const dir = len ? [dx/len, dy/len, dz/len] : [0,0,0];
    Ssegs.push({ s0: acc, s1: acc+len, len, dir, start: seg.start, end: seg.end, tCode: seg.tCode });
    acc += len;
  }
  const total = acc;

  function worldPointAtS(s){ // clamp to path
    if(!Ssegs.length) return [0,0,0];
    if(s<=0) return Ssegs[0].start.slice();
    if(s>=total) return Ssegs[Ssegs.length-1].end.slice();
    for(const sg of Ssegs){
      if(s>=sg.s0-1e-9 && s<=sg.s1+1e-9){
        const t = sg.len ? (s - sg.s0)/sg.len : 0;
        return [
          sg.start[0] + (sg.end[0]-sg.start[0])*t,
          sg.start[1] + (sg.end[1]-sg.start[1])*t,
          sg.start[2] + (sg.end[2]-sg.start[2])*t
        ];
      }
    }
    return Ssegs[Ssegs.length-1].end.slice();
  }

  function sOfSegParam(segIdx, t){ // t in [0,1]
    const sg = Ssegs[segIdx]; if(!sg) return 0;
    return sg.s0 + (Math.max(0, Math.min(1, t)) * sg.len);
  }

  return { Ssegs, total, worldPointAtS, sOfSegParam };
}
/* Station-based keep-outs (in S units, inches since segments are inches) */
function buildKeepoutsS(model, edgeClearIn, jointClearIn){
  const K = [];
  // edges
  K.push([0, edgeClearIn]);
  K.push([Math.max(0, model.total - edgeClearIn), model.total]);

  // forbidden entire segments: C,V,T,W (pad each end by jointClearIn)
  for(const [i, sg] of model.Ssegs.entries()){
    if(['C','V','T','W'].includes(sg.tCode)){
      K.push([Math.max(0, sg.s0 - jointClearIn), Math.min(model.total, sg.s1 + jointClearIn)]);
    }
  }

  // joints: every internal junction ±jointClearIn
  for(const sg of model.Ssegs){
    if(sg.s0>0) K.push([sg.s0 - jointClearIn, sg.s0 + jointClearIn]);
  }
  // final joint (end)
  if(model.total>0) K.push([model.total - jointClearIn, model.total + jointClearIn]);

  return mergeWindows(K);
}

/* Weighted CG on station using where the weights live along the run */
function computeCGStation(model){
  let TW = 0, SW = 0;

  // lumps are placed at segment mids — we know segIdx so S is simple:
  for(const L of lumps){
    const s = model.sOfSegParam(L.segIdx ?? 0, 0.5);
    TW += L.w; SW += L.w * s;
  }
  // auto couplings at joints (between every pair of segments)
  for(let j=0; j<segments.length-1; j++){
    const sJoint = model.Ssegs[j].s1; // end of segment j
    TW += W_COUP; SW += W_COUP * sJoint;
  }
  // explicit couplings already counted via lumps/segments as weight-only segments (if any)

  const sCG = TW ? (SW/TW) : 0; // inches of chainage from start
  return { sCG, TW };
}

/* Find symmetric pair about sCG on station with keep-outs and spread limit */
function findSymmetricPairS(model, sCG, minOffsetIn, maxSpreadIn, keepoutsS){
  const step = 0.5; // 1/2" station step
  const maxOff = model.total/2;
  const allowedS = (s)=>{ for(const w of keepoutsS){ if(s>=w[0] && s<=w[1]) return false; } return true; };

  for(let off=Math.max(0, minOffsetIn); off<=maxOff+1e-6; off+=step){
    let a = sCG - off, b = sCG + off;
    a = Math.max(0, Math.min(model.total, a));
    b = Math.max(0, Math.min(model.total, b));
    if(b - a > maxSpreadIn) continue;

    // nudge outwards symmetrically if either side lands in a keep-out
    if(allowedS(a) && allowedS(b)) return {ok:true, s1:a, s2:b, note:null};

    let aa=a, bb=b;
    for(let k=1; k*step <= model.total+120; k++){
      const a2 = aa - step, b2 = bb + step;
      if(a2 < 0 || b2 > model.total) break;
      if(b2 - a2 > maxSpreadIn) break;
      if(allowedS(a2) && allowedS(b2)) return {ok:true, s1:a2, s2:b2, note:'nudged'};
      aa = a2; bb = b2;
    }
  }
  return {ok:false, note:'no legal symmetric pair on station'};
}

/* ---------- keep-out utilities ---------- */
/* Collect windows on a given axis where attachments are forbidden */
function buildKeepouts(axisIndex, edgeClearIn, jointClearIn){
  const ex = extentAlong(axisIndex);
  const K = [];
  // Global edges (6")
  K.push([ex.min, ex.min + edgeClearIn]);
  K.push([ex.max - edgeClearIn, ex.max]);

  // Per-segment forbidden spans
  for(const seg of segments){
    const a0 = seg.start[axisIndex], a1 = seg.end[axisIndex];
    const mn = Math.min(a0,a1), mx = Math.max(a0,a1);

    // Entire segment forbidden for these types:
    // C=coupling, V=valve, T=tee, W=tee+valve
    if(['C','V','T','W'].includes(seg.tCode)){
      K.push([mn - jointClearIn, mx + jointClearIn]); // pad by 2"
    }
  }

  // Joints: ±2" around every internal joint
  for(let j=0;j<segments.length-1;j++){
    const end = segments[j].end[axisIndex];
    K.push([end - jointClearIn, end + jointClearIn]);
  }

  return mergeWindows(K);
}
function mergeWindows(wins){
  if(!wins.length) return [];
  wins.sort((A,B)=>A[0]-B[0]);
  const out=[wins[0].slice()];
  for(let i=1;i<wins.length;i++){
    const w=wins[i], last=out[out.length-1];
    if(w[0] <= last[1]) last[1] = Math.max(last[1], w[1]);
    else out.push(w.slice());
  }
  return out;
}
function allowedPoint(x, wins){ for(const w of wins){ if(x>=w[0] && x<=w[1]) return false; } return true; }

/* Try to place a symmetric pair about CG along an axis, avoiding keep-outs and respecting spread & edges.
   Returns: {ok, p1, p2, note} with p1<=p2 if ok; else {ok:false, note} */
function findSymmetricPair(axisIndex, ex, cgCoord, keepouts, minOffsetIn, pulleySpreadMaxIn){
  // Start from some offset >= minOffsetIn and try outward, shrinking if needed
  // Because spacing "doesn't matter", we'll prefer the smallest legal offset from CG.
  const step = 0.5; // 1/2" search
  const maxOffset = ex.span/2; // can't exceed half-span
  let best = null;

  // We'll walk offset from minOffsetIn up to maxOffset
  for(let off = Math.max(minOffsetIn, 0); off <= maxOffset + 1e-6; off += step){
    let a = cgCoord - off, b = cgCoord + off;

    // clamp to extents
    a = Math.max(ex.min, Math.min(ex.max, a));
    b = Math.max(ex.min, Math.min(ex.max, b));

    // ensure ordering
    if(a>b){ const t=a; a=b; b=t; }

    // spread check
    if((b-a) > pulleySpreadMaxIn) continue;

    // if either point is in keepout → try nudging both outward symmetrically
    const tryNudge = ()=>{
      if(allowedPoint(a, keepouts) && allowedPoint(b, keepouts)) return {ok:true, p1:a, p2:b, note:null};

      // nudge outward while within extents and under spread limit
      const maxShift = ex.span + 120;
      for(let k=1; k*step <= maxShift; k++){
        let a2 = a - step, b2 = b + step;
        if(a2 < ex.min || b2 > ex.max) break;
        if((b2 - a2) > pulleySpreadMaxIn) break;
        if(allowedPoint(a2, keepouts) && allowedPoint(b2, keepouts)) return {ok:true, p1:a2, p2:b2, note:'nudged'};
        a = a2; b = b2;
      }
      return {ok:false, note:'blocked by keep-outs'};
    };

    const res = tryNudge();
    if(res.ok){ best = res; break; }
  }

  return best || {ok:false, note:'no legal symmetric pair on axis'};
}

/* When axisSecond === 'NONE', place two pairs on X (4-on-X).
   We choose an inner pair (near CG) and an outer pair (further out), both legal. */
function findTwoPairsOnOneAxis(axisIndex, ex, cgCoord, keepouts, minOffsetIn, pulleySpreadMaxIn){
  const inner = findSymmetricPair(axisIndex, ex, cgCoord, keepouts, minOffsetIn, pulleySpreadMaxIn);
  if(!inner.ok) return {ok:false, note:'inner pair failed: '+inner.note};

  // For the outer pair, start beyond inner by +12" and search
  const outerStart = Math.max(minOffsetIn, (inner.p2 - cgCoord) + 12);
  const outer = findSymmetricPair(axisIndex, ex, cgCoord, keepouts, outerStart, pulleySpreadMaxIn);
  if(!outer.ok) return {ok:false, note:'outer pair failed: '+outer.note};

  return {ok:true, inner, outer};
}

/* Utility: decide second axis given UI choice and spans */
function decideSecondAxis(choice, spanY, spanZ){
  if(choice==='Y'||choice==='Z'||choice==='NONE') return choice;
  // AUTO: prefer Y if spanY >= 12", else Z if spanZ >= 12", else NONE
  if(spanY >= 12) return 'Y';
  if(spanZ >= 12) return 'Z';
  return 'NONE';
}

/* ---------- state ---------- */
let items=[], segments=[], marks=[], lumps=[], itemsFoot=[];

/* ---------- UI wiring ---------- */
window.addEventListener('load', ()=>{
  el('itemType').addEventListener('change', updateDetailRows);
  el('addBtn').addEventListener('click', addItem);
  el('clearBtn').addEventListener('click', resetAll);
  el('delLastBtn').addEventListener('click', deleteLastItem);
  el('computeBtn').addEventListener('click', computeAndDraw);
  el('downloadBtn').addEventListener('click', ()=>{
    const a=document.createElement('a'); const ts=new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
    a.download=ts+'_rigging.png'; a.href=sheet.toDataURL('image/png'); a.click();
  });
  el('btnPlumb45').addEventListener('click', ()=>{ el('targetRoll').value=45; });
  updateDetailRows();
});

function updateDetailRows(){
  const t=el('itemType').value;
  el('lenRow').style.display = (t==='P'||t==='X')?'grid':'none';
  el('wpiLabel').style.display = (t==='P'||t==='X')?'block':'none';
  el('fixedRow').style.display = (t==='Y')?'grid':'none';
  el('turnRow').style.display = (t==='E'||t==='F'||t==='T'||t==='W') ? 'block' : 'none';
}

/* ---------- geometry + building ---------- */
function getEnd(){ return segments.length===0?[0,0,0]:segments[segments.length-1].end.slice(); }
function pushSegment(tCode, dir, L, labelIdx){
  const s=getEnd(), e=[s[0]+dir[0]*L, s[1]+dir[1]*L, s[2]+dir[2]*L];
  segments.push({tCode, start:s, end:e});
  const mid=[(s[0]+e[0])/2,(s[1]+e[1])/2,(s[2]+e[2])/2];
  marks.push([labelIdx, mid[0], mid[1], mid[2]]);
}
function addItemRow(idx, txt){
  const d=document.createElement('div'); d.className='item'; d.textContent=(idx+'. '+txt); el('items').appendChild(d);
}
function parseTurnDir(){
  const v = el('turnTo').value || 'NONE';
  return v==='NONE' ? null : AXDIR[v];
}
function unitFromOrient(code){ return ORIENTS[code] || [1,0,0]; }
function addLumpAtSegmentMid(segIdx, w){
  const s=segments[segIdx].start, e=segments[segIdx].end;
  const p=mid3(s,e);
  lumps.push({p, w, segIdx}); // keep seg index for stationing
}


/* push a sub-leg and return its segment index */
function pushLeg(dir, L, labelIdx, tCode){
  const sIdx = segments.length;
  pushSegment(tCode, dir, L, labelIdx);
  return sIdx;
}
/* Build a 2-leg part (orthogonal legs), allocate weight by leg length proportion */
function addTurnedPart(labelIdx, tCode, totalLen, totalW, dirStart, dirTurn, splitRatio){
  const r = (typeof splitRatio==='number') ? Math.max(0, Math.min(1, splitRatio)) : 0.5;
  const L1 = totalLen * r;
  const L2 = totalLen - L1;
  const s1 = pushLeg(dirStart, Math.max(0,L1), labelIdx, tCode);
  const s2 = pushLeg(dirTurn, Math.max(0,L2), labelIdx, tCode);
  const W1 = totalLen>0 ? totalW * (L1/totalLen) : totalW/2;
  const W2 = totalW - W1;
  if(L1>0) addLumpAtSegmentMid(s1, W1);
  if(L2>0) addLumpAtSegmentMid(s2, W2);
}

/* add items */
function addItem(){
  try{
    const t=el('itemType').value, idx=items.length+1, d=unitFromOrient(el('orient').value);
    const seg0 = segments.length;
const lump0 = lumps.length;

    function placeLinear(name, L, W, xcgLocal, tCode){
      L=Math.max(0, Number(L)||0);
      if(xcgLocal==null) xcgLocal=L/2;
      items.push({name, length:L, weight:W, xcg_local:xcgLocal, tCode});
      const segIdx = segments.length;
      pushSegment(tCode, d, L, idx);
      addLumpAtSegmentMid(segIdx, W); // weight at mid
    }

    if(t==='P'){
      const L=Number(el('lenIn').value)||0, wpi=Number(el('wpi').value)||W_PER_IN_DEFAULT;
      const W=wpi*L; placeLinear('24" pipe', L, W, null, 'P');
      const startAx = axisLabel(d);
addItemRow(idx, `Pipe ${L.toFixed(1)} in @ ${wpi} → ${W.toFixed(1)} lb  [dir: ${startAx} ${dirLayman(startAx)}]`);
      
    }else if(t==='X'){
      const Lx=Number(el('lenIn').value)||0, wpiX=Number(el('wpi').value)||W_PER_IN_DEFAULT;
      const WX=wpiX*Lx; placeLinear('Custom per-inch', Lx, WX, null, 'X');
      const startAx = axisLabel(d);
addItemRow(idx, `Custom per-inch ${Lx.toFixed(1)} in @ ${wpiX} → ${WX.toFixed(1)} lb  [dir: ${startAx} ${dirLayman(startAx)}]`);
      
    }else if(t==='Y'){
      const WY=Number(el('fixedW').value)||0, LY=Number(el('fixedL').value)||0;
      placeLinear('Custom fixed', LY, WY, null, 'Y');
      const startAx = axisLabel(d);
addItemRow(idx, `Custom fixed ${WY.toFixed(1)} lb, eff L=${LY.toFixed(1)} in  [dir: ${startAx} ${dirLayman(startAx)}]`);
      
    }else if(t==='V'){
      const LV=L_VALVE_STD, WV=W_VALVE_BODY;
      placeLinear('Valve (regular)', LV, WV, LV/2, 'V');
      const startAx = axisLabel(d);
addItemRow(idx, `Valve reg L=${LV} in, W=${WV.toFixed(1)} lb  [dir: ${startAx} ${dirLayman(startAx)}]`);
      
    }else if(t==='C'){
      items.push({name:'Coupling', length:0, weight:W_COUP, xcg_local:0, tCode:'C'});
      pushSegment('C', d, 1, idx); // visual stub
      const startAx = axisLabel(d);
addItemRow(idx, `Coupling W=${W_COUP.toFixed(1)} lb  [dir: ${startAx} ${dirLayman(startAx)}]`);
      
    }else if(t==='E'){ // 90° elbow
      const dirTurn = parseTurnDir();
      if(!dirTurn || !sameOrtho(d, dirTurn)){ throw 'Select a valid orthogonal "Turn to" for the elbow.'; }
      const Ltot = S_EL90, Wtot = W_EL90;
      items.push({name:'90° elbow', length:Ltot, weight:Wtot, xcg_local:null, tCode:'E'});
      addTurnedPart(idx, 'E', Ltot, Wtot, d, dirTurn, 0.5);
const startAx = axisLabel(d), turnAx = axisLabel(dirTurn);
addItemRow(idx, `90° elbow split along ${startAx} ${dirLayman(startAx)} → ${turnAx} ${dirLayman(turnAx)} (L=${Ltot} in, W=${Wtot.toFixed(1)} lb)`);

    }else if(t==='F'){ // 45° elbow
      const dirTurn = parseTurnDir();
      if(!dirTurn || !sameOrtho(d, dirTurn)){ throw 'Select a valid orthogonal "Turn to" for the elbow.'; }
      const Ltot = S_EL45, Wtot = W_EL45;
      items.push({name:'45° elbow', length:Ltot, weight:Wtot, xcg_local:null, tCode:'F'});
      addTurnedPart(idx, 'F', Ltot, Wtot, d, dirTurn, 0.5);
const startAx = axisLabel(d), turnAx = axisLabel(dirTurn);
addItemRow(idx, `45° elbow split along ${startAx} ${dirLayman(startAx)} → ${turnAx} ${dirLayman(turnAx)} (L=${Ltot} in, W=${Wtot.toFixed(1)} lb)`);

    }else if(t==='T'){ // Tee
      const dirTurn = parseTurnDir();
      if(!dirTurn || !sameOrtho(d, dirTurn)){ throw 'Select a valid orthogonal "Turn to" for the tee.'; }
      const Ltot = L_TEE, Wtot = W_TEE_BODY;
      items.push({name:'Tee (plain)', length:Ltot, weight:Wtot, xcg_local:null, tCode:'T'});
      addTurnedPart(idx, 'T', Ltot, Wtot, d, dirTurn, 0.5);
const startAx = axisLabel(d), turnAx = axisLabel(dirTurn);
addItemRow(idx, `Tee split along ${startAx} ${dirLayman(startAx)} → ${turnAx} ${dirLayman(turnAx)} (L=${Ltot} in, W=${Wtot.toFixed(1)} lb)`);

    }else if(t==='W'){ // Tee + valve
      const dirTurn = parseTurnDir();
      if(!dirTurn || !sameOrtho(d, dirTurn)){ throw 'Select a valid orthogonal "Turn to" for the tee+valve.'; }
      const LW=L_TEE, WT=W_TEE_BODY+W_VALVE_BODY;
      items.push({name:'Tee + valve', length:LW, weight:WT, xcg_local:null, tCode:'W'});
      addTurnedPart(idx, 'W', LW, W_TEE_BODY, d, dirTurn, 0.5);
      const segIdx = segments.length; // valve lump on branch
      pushSegment('V', dirTurn, 1, idx);
      addLumpAtSegmentMid(segIdx, W_VALVE_BODY);
const startAx = axisLabel(d), turnAx = axisLabel(dirTurn);
addItemRow(idx, `Tee+valve ${startAx} ${dirLayman(startAx)} → ${turnAx} ${dirLayman(turnAx)} (L=${LW} in, Tee=${W_TEE_BODY.toFixed(1)} lb, Valve=${W_VALVE_BODY.toFixed(1)} lb)`);
    }
// record footprint (how many new segments & lumps were appended by this item)
itemsFoot.push({
  segs: segments.length - seg0,
  lumps: lumps.length - lump0
});

    el('debug').textContent='debug: items='+items.length;
  }catch(e){
    el('debug').textContent='debug: addItem error: '+e;
  }
}

function resetAll(){
  items=[]; segments=[]; marks=[]; lumps=[]; itemsFoot=[];
  el('items').innerHTML='';
  el('summary').innerHTML='Add items and click “Compute + Draw”.';
  ctx.clearRect(0,0,sheet.width,sheet.height);
  el('debug').textContent='debug: reset';
}
function deleteLastItem(){
  if(items.length===0) { el('debug').textContent='debug: nothing to delete'; return; }

  // Remove last item footprint (how many segments/lumps it added)
  const fp = itemsFoot.pop();
  if(!fp){ el('debug').textContent='debug: no footprint, cannot delete safely'; return; }

  // Trim segments & marks for this item
  if(fp.segs>0){
    segments.splice(segments.length - fp.segs, fp.segs);
    marks.splice(marks.length - fp.segs, fp.segs);
  }
  // Trim lumps for this item
  if(fp.lumps>0){
    lumps.splice(lumps.length - fp.lumps, fp.lumps);
  }

  // Remove the item record and the last UI row
  items.pop();
  const list = el('items');
  if(list && list.lastElementChild) list.removeChild(list.lastElementChild);

  el('debug').textContent = 'debug: deleted last item; remaining items='+items.length;
}


/* ---------- CG with auto couplings at joints (weight only) ---------- */
function computeCG(){
  let totalW=0, sum=[0,0,0];
  for(const L of lumps){ totalW += L.w; sum = addV(sum, mulV(L.p, L.w)); }
  for(let j=0;j<segments.length-1;j++){
    const end=segments[j].end; totalW += W_COUP; sum = addV(sum, mulV(end, W_COUP));
  }
  return { CG: totalW ? mulV(sum,1/totalW) : [0,0,0], totalW };
}

/* ---------- axis utilities ---------- */
function extentAlong(axisIndex){
  const arr=[]; for(let i=0;i<segments.length;i++){ arr.push(segments[i].start[axisIndex], segments[i].end[axisIndex]); }
  const mn=Math.min.apply(null,arr), mx=Math.max.apply(null,arr);
  return {min:mn, max:mx, span:mx-mn};
}
function chooseAxis(sel){
  if(sel!=='AUTO') return sel;
  const exX=extentAlong(0), exY=extentAlong(1), exZ=extentAlong(2);
  let best='X', span=exX.span;
  if(exY.span>span){ best='Y'; span=exY.span; }
  if(exZ.span>span){ best='Z'; span=exZ.span; }
  return best;
}

/* ---------- coupling avoidance windows (±clear around every coupling) ---------- */
function couplingWindows(axisIndex, clear){
  const windows=[];
  // explicit coupling segments
  for(let i=0;i<segments.length;i++){
    const code=segments[i].tCode;
    if(code==='C'){
      const s=segments[i].start[axisIndex], e=segments[i].end[axisIndex];
      const pos=(s+e)/2; windows.push([pos-clear, pos+clear]);
    }
  }
  // auto couplings at each joint
  for(let j=0;j<segments.length-1;j++){
    const end=segments[j].end; const pos=end[axisIndex];
    windows.push([pos-clear, pos+clear]);
  }
  windows.sort((A,B)=>A[0]-B[0]);
  const merged=[];
  for(const w of windows){
    if(!merged.length || w[0]>merged[merged.length-1][1]) merged.push(w.slice());
    else merged[merged.length-1][1]=Math.max(merged[merged.length-1][1], w[1]);
  }
  return merged;
}
function allowed(x, windows){ for(const w of windows){ if(x>=w[0] && x<=w[1]) return false; } return true; }
function placeSinglePick(axisIndex, target, ext, windows){
  const step=0.5, maxShift=ext.span+120;
  if(target<ext.min) target=ext.min;
  if(target>ext.max) target=ext.max;
  if(allowed(target, windows)) return {pos:target, note:null};
  for(let k=1; k*step<=maxShift; k++){
    const d=k*step, a=target-d, b=target+d;
    if(a>=ext.min && allowed(a, windows)) return {pos:a, note:'Nudged to clear coupling'};
    if(b<=ext.max && allowed(b, windows)) return {pos:b, note:'Nudged to clear coupling'};
  }
  return {pos:Math.max(ext.min, Math.min(ext.max, target)), note:'Could not fully clear all couplings'};
}

 function computeAndDraw(){
  if(items.length===0){ alert('Add at least one item.'); return; }

  // --- CG in world (for totals + roll info)
  const {CG,totalW}=computeCG();

  // --- Station (chainage) model for 2-pick placement (real-world along-the-run)
  const station = buildStationModel();
  const edgeClear = 6;                // keep off ends
  const jointClear = 2;               // joints ±2"
  const pulleySpreadMaxIn = 240;      // 20 ft per pair
  const minOffsetIn = Math.max(0, Number(el('minPairOffset').value)||12);

  const Kstation = buildKeepoutsS(station, edgeClear, jointClear);
  const { sCG } = computeCGStation(station);
  const pairS = findSymmetricPairS(station, sCG, minOffsetIn, pulleySpreadMaxIn, Kstation);

  // World positions for 2-pick (these are points on the actual 3D run)
  let PleftW = null, PrightW = null, pairNote = null;
  if(pairS.ok){
    PleftW  = station.worldPointAtS(pairS.s1);
    PrightW = station.worldPointAtS(pairS.s2);
    pairNote = pairS.note;
  }else{
    // fallback: both at CG station (rare; still drawn)
    PleftW = PrightW = station.worldPointAtS(sCG);
    pairNote = pairS.note;
  }

  // --- Extents along axes (for reporting and 4-pick solver)
  const exX = extentAlong(0);
  const exY = extentAlong(1);
  const exZ = extentAlong(2);

// ---------- FOUR-PICK SOLVER ----------
const edgeClear4 = edgeClear; // 6 inches
const jointClear4 = jointClear; // 2 inches
const pulleySpreadMaxIn4 = pulleySpreadMaxIn; // 240 inches
const minOffsetIn4 = minOffsetIn; // User-defined, default 12 inches
// Keep-outs per axis
const Kx = buildKeepouts(0, edgeClear4, jointClear4);
const Ky = buildKeepouts(1, edgeClear4, jointClear4);
const Kz = buildKeepouts(2, edgeClear4, jointClear4);
// Second axis decision
const axis2Choice = (el('axisSecond')?.value) || 'AUTO';
const axis2 = decideSecondAxis(axis2Choice, exY.span, exZ.span); // 'Y' | 'Z' | 'NONE'
// Initialize picks
const fourPicks = { list: [], notes: [] };
// X pair (always required)
const pairX = findSymmetricPair(0, exX, CG[0], Kx, minOffsetIn4, pulleySpreadMaxIn4);
if (pairX.ok) {
  fourPicks.list.push({ axis: 'X', pos: pairX.p1, label: 'X1', color: COLORS.pX1 });
  fourPicks.list.push({ axis: 'X', pos: pairX.p2, label: 'X2', color: COLORS.pX2 });
} else {
  fourPicks.notes.push('Could not place X pair: ' + pairX.note);
}
// Second pair or fallback
if (axis2 === 'Y' && exY.span >= 12) {
  const pairY = findSymmetricPair(1, exY, CG[1], Ky, minOffsetIn4, pulleySpreadMaxIn4);
  if (pairY.ok) {
    fourPicks.list.push({ axis: 'Y', pos: pairY.p1, label: 'Y1', color: COLORS.pS1 });
    fourPicks.list.push({ axis: 'Y', pos: pairY.p2, label: 'Y2', color: COLORS.pS2 });
  } else {
    fourPicks.notes.push('Could not place Y pair: ' + pairY.note);
  }
} else if (axis2 === 'Z' && exZ.span >= 12) {
  const pairZ = findSymmetricPair(2, exZ, CG[2], Kz, minOffsetIn4, pulleySpreadMaxIn4);
  if (pairZ.ok) {
    fourPicks.list.push({ axis: 'Z', pos: pairZ.p1, label: 'Z1', color: COLORS.pS1 });
    fourPicks.list.push({ axis: 'Z', pos: pairZ.p2, label: 'Z2', color: COLORS.pS2 });
  } else {
    fourPicks.notes.push('Could not place Z pair: ' + pairZ.note);
  }
}
// Fallback: If fewer than 4 picks, try 4-on-X
if (fourPicks.list.length < 4) {
  const twoX = findTwoPairsOnOneAxis(0, exX, CG[0], Kx, minOffsetIn4, pulleySpreadMaxIn4);
  if (twoX.ok) {
    fourPicks.list = [
      { axis: 'X', pos: twoX.inner.p1, label: 'X1', color: COLORS.pX1 },
      { axis: 'X', pos: twoX.inner.p2, label: 'X2', color: COLORS.pX2 },
      { axis: 'X', pos: twoX.outer.p1, label: 'X3', color: COLORS.pS1 },
      { axis: 'X', pos: twoX.outer.p2, label: 'X4', color: COLORS.pS2 },
    ];
    fourPicks.notes.push('Used 4-on-X due to ' + (axis2 === 'NONE' ? 'user choice' : 'Y/Z constraints'));
  } else {
    fourPicks.notes.push('4-on-X failed: ' + twoX.note);
  }
}
// Spread warnings
function checkSpreadWarn(axis, a, b) {
  if (Math.abs(b - a) > pulleySpreadMaxIn4) {
    fourPicks.notes.push(axis + ' pair exceeds 20′; add more rigging');
  }
}
const getExt = ax => ax === 'X' ? exX : (ax === 'Y' ? exY : exZ);
const seenAxes = new Map();
for (const pk of fourPicks.list) {
  if (!seenAxes.has(pk.axis)) seenAxes.set(pk.axis, []);
  seenAxes.get(pk.axis).push(pk.pos);
}
for (const [ax, arr] of seenAxes) {
  if (arr.length >= 2) checkSpreadWarn(ax, arr[0], arr[arr.length - 1]);
}
// Build output lines
const outLines = [];
fourPicks.list.sort((A, B) => (A.axis === B.axis) ? (A.pos - B.pos) : (A.axis < B.axis ? -1 : 1));
for (const pk of fourPicks.list) {
  const ex = getExt(pk.axis);
  outLines.push(`${pk.axis}-Axis: Pick-${pk.label} = ${fmtInchesQ(pk.pos - ex.min)} from ${edgeName(pk.axis)}`);
}
const FOUR = { picks: fourPicks, lines: outLines };
  // --- Single-pick (CG) distances from edges (for quick reference)
  const dX = (exX.span>0)? (CG[0]-exX.min) : 0;
  const dY = (exY.span>0)? (CG[1]-exY.min) : 0;
  const dZ = (exZ.span>0)? (CG[2]-exZ.min) : 0;

  // --- 2-pick reporting using selected axes, but positions come from world points
  const axisL = chooseAxis(el('axisL').value);
  const axisR = chooseAxis(el('axisR').value);
  const axL = (axisL==='X'?0:(axisL==='Y'?1:2));
  const axR = (axisR==='X'?0:(axisR==='Y'?1:2));
  const exL = (axisL==='X'?exX:(axisL==='Y'?exY:exZ));
  const exR = (axisR==='X'?exX:(axisR==='Y'?exY:exZ));
  const posL_axis = Math.max(exL.min, Math.min(exL.max, PleftW[axL]));
  const posR_axis = Math.max(exR.min, Math.min(exR.max, PrightW[axR]));

  // --- Roll info
  const R=(Number(el('pipeOD').value)||24)/2;
  const y=CG[1], yclamped=Math.max(-R, Math.min(R, y));
  const rollDegInfo = (R>0)? (Math.asin(yclamped/R)*180/Math.PI) : 0;
  const rollSideInfo = (y>0?'toward +Y':(y<0?'toward -Y':'no roll needed'));
  const arc = R * (Math.abs(rollDegInfo)*Math.PI/180);

  let targetRoll = parseFloat(el('targetRoll').value);
  if(!(targetRoll===0 || !!targetRoll)) targetRoll = 0;

  // --- Output HTML
  let html='';
  html += '<h3>Totals</h3>';
  html += '<div>Total weight: <b>'+totalW.toFixed(1)+' lb</b></div>';
  html += '<div>CG (in): X=<b>'+CG[0].toFixed(2)+'</b>, Y=<b>'+CG[1].toFixed(2)+'</b>, Z=<b>'+CG[2].toFixed(2)+'</b></div>';

  html += '<h3>Single pick (center of gravity)</h3>';
  const parts=[];
  if(exX.span>0) parts.push(fmtInchesQ(dX)+' from the '+edgeName('X'));
  if(exY.span>0) parts.push(fmtInchesQ(dY)+' from the '+edgeName('Y'));
  if(exZ.span>0) parts.push(fmtInchesQ(dZ)+' from the '+edgeName('Z'));
  if(parts.length){ html += '<div><b>'+parts.join(' and ')+'</b>.</div>'; }

  // Pick points (station/world aware)
  html += '<h3>Pick Points</h3>';
  html += '<div><span class="pill left">Left pick</span> axis <b>'+axisL+'</b>: '
        + fmtFtIn(posL_axis - exL.min) + ' from Left Edge';
  html += ' &nbsp; <span class="muted">(Z at pick: '+PleftW[2].toFixed(2)+'")</span></div>';

  html += '<div><span class="pill right">Right pick</span> axis <b>'+axisR+'</b>: '
        + fmtFtIn(posR_axis - exR.min) + ' from Left Edge';
  html += ' &nbsp; <span class="muted">(Z at pick: '+PrightW[2].toFixed(2)+'")</span></div>';

  if(pairNote){ html += '<div class="muted">Pair note: '+pairNote+'</div>'; }

  // Roll
  html += '<h3>Roll</h3>';
  html += '<div><span class="pill roll">CG roll (info)</span> ≈ '+rollDegInfo.toFixed(1)+'° '+rollSideInfo+'; circumference offset per choker ≈ '+(r8(arc)).toFixed(3).replace(/\\.000$/,'')+'"</div>';
  html += '<div style="margin-top:8px;"><span class="bigcall">SET PIPE ROLL: '+(targetRoll>=0?'+':'')+targetRoll.toFixed(1)+'° (toward '+(targetRoll>=0?'+Y':'−Y')+')</span></div>';
  html += '<div class="muted">This is the roll you give to the operator on the pipe. Use the preset above to “plumb the 45° face” (sets +45°).</div>';

  // 4-pick output
  html += '<h3>4-Pick Positions</h3>';
  if(FOUR.lines.length){
    html += '<div>'+FOUR.lines.map(s=>('<div>'+s+'</div>')).join('')+'</div>';
  }else{
    html += '<div class="muted">Could not determine 4 picks under current constraints.</div>';
  }
  if(FOUR.picks.notes.length){
    html += '<div class="muted">'+FOUR.picks.notes.join(' · ')+'</div>';
  }

  el('summary').innerHTML = html;

  // Draw
  drawAll({
    axisL, axisR,
    posL: posL_axis, posR: posR_axis,   // used only for labels/edge-readouts
    PleftW, PrightW,                    // true 3D world pick points
    targetRoll, rollDegInfo, CG,
    FOUR
  });

  el('downloadBtn').disabled=false;
}
 
  el('summary').innerHTML = html;

drawAll({
  axisL, axisR,
  // axis values only used for labels; we’ll also pass world points:
  posL: posL_axis, posR: posR_axis,
  PleftW, PrightW,                // <-- new
  targetRoll, rollDegInfo, CG,
  FOUR                            // keep your 4-pick object for dot overlays
});


/* ---------- drawing ---------- */
function drawAll(picks){
  ctx=setupCanvas(sheet, 1000, 1050);
  const W=1000,H=1050,pad=28, secH=Math.floor((H-pad*4)/2);
  const planRect={x:pad,y:pad,w:W-2*pad,h:secH};
  const elevRect={x:pad,y:pad*2+secH,w:W-2*pad,h:secH};

  ctx.fillStyle='#fff'; ctx.fillRect(0,0,W,H);

  const verts=[[0,0,0]]; for(let i=0;i<segments.length;i++){ verts.push(segments[i].end.slice()); }
  const px=verts.map(v=>v[0]), py=verts.map(v=>v[1]), pz=verts.map(v=>v[2]);

  drawProjection(planRect, px, py, 'Plan (X–Y)', picks, 'XY', picks.CG);
  drawProjection(elevRect, px, pz, 'Elevation (X–Z)', picks, 'XZ', picks.CG);

  drawRollDial(W/2, H-120, 90, picks.targetRoll);
}

function drawCGBullseye(x, y, label){
  ctx.save();
  ctx.lineWidth = 2;
  ctx.strokeStyle = '#000';
  for (let r of [8, 14, 20]) { ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.stroke(); }
  ctx.beginPath(); ctx.moveTo(x-26, y); ctx.lineTo(x+26, y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x, y-26); ctx.lineTo(x, y+26); ctx.stroke();
  const pad=4, text = label || 'CG';
  ctx.font = '12px system-ui';
  const tw = ctx.measureText(text).width;
  const bx = x + 10, by = y - 12, bw = tw + pad*2, bh = 18;
  ctx.fillStyle = '#fff'; ctx.strokeStyle = '#cfd4d9'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.rect(bx, by, bw, bh); ctx.fill(); ctx.stroke();
  ctx.fillStyle = '#000'; ctx.fillText(text, bx+pad, by+3);
  ctx.restore();
}

function drawProjection(rect, px, py, title, picks, plane, cgWorld){
  const minX=Math.min.apply(null, px.concat([0])), maxX=Math.max.apply(null, px.concat([1]));
  const minY=Math.min.apply(null, py.concat([-1])), maxY=Math.max.apply(null, py.concat([1]));

  const pad=46, sx=(rect.w-pad*2)/((maxX-minX)||1), sy=(rect.h-pad*2)/((maxY-minY)||1), s=Math.min(sx,sy);
  const mapX=x=>rect.x+pad+(x-minX)*s;
  const mapY=y=>rect.y+rect.h-pad-(y-minY)*s;

  ctx.fillStyle='#000'; ctx.font='18px system-ui'; ctx.fillText(title, rect.x, rect.y-6);

  // axes
  ctx.lineWidth=2;
  ctx.strokeStyle=COLORS.axisX; ctx.beginPath(); ctx.moveTo(mapX(minX), mapY(0)); ctx.lineTo(mapX(maxX), mapY(0)); ctx.stroke();
  ctx.strokeStyle=(plane==='XY')?COLORS.axisY:COLORS.axisZ;
  const x0=mapX(0); ctx.beginPath(); ctx.moveTo(x0, mapY(minY)); ctx.lineTo(x0, mapY(maxY)); ctx.stroke();

  // pipe band & centerlines
  const thickness=Math.min(28, Math.max(8, s*24*0.6)); ctx.lineCap='round';
  segments.forEach(seg=>{
    const sx0=mapX(seg.start[0]), sy0=mapY(plane==='XY'?seg.start[1]:seg.start[2]);
    const sx1=mapX(seg.end[0]),   sy1=mapY(plane==='XY'?seg.end[1]:seg.end[2]);
    ctx.strokeStyle=COLORS.pipeBand; ctx.lineWidth=thickness; ctx.beginPath(); ctx.moveTo(sx0,sy0); ctx.lineTo(sx1,sy1); ctx.stroke();
  });
  segments.forEach(seg=>{
    const sx0=mapX(seg.start[0]), sy0=mapY(plane==='XY'?seg.start[1]:seg.start[2]);
    const sx1=mapX(seg.end[0]),   sy1=mapY(plane==='XY'?seg.end[1]:seg.end[2]);
    ctx.strokeStyle=COLORS[seg.tCode]||COLORS.centerline; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(sx0,sy0); ctx.lineTo(sx1,sy1); ctx.stroke();
  });

  // segment labels
  ctx.fillStyle='#000'; ctx.font='13px system-ui';
  for(let m=0;m<marks.length;m++){
    const mk=marks[m]; const x=mk[1], y=(plane==='XY'?mk[2]:mk[3]);
    ctx.fillText(String(mk[0]), mapX(x)+4, mapY(y)-16);
  }

  // pick markers
  function drawTopPill(x,y,w,h,color,label){
    ctx.fillStyle=color; ctx.strokeStyle=color; const r=h/2;
    ctx.beginPath();
    ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y);
    ctx.arc(x+w-r,y+r,r,-Math.PI/2,Math.PI/2);
    ctx.lineTo(x+r,y+h); ctx.arc(x+r,y+r,r,Math.PI/2,Math.PI*1.5);
    ctx.closePath(); ctx.fill(); ctx.fillStyle='#000'; ctx.font='12px system-ui'; ctx.fillText(label, x+8, y+3);
  }
  function drawLeader(x1,y1,x2,y2,color){
    ctx.strokeStyle=color; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  }
  function drawPickMarker(x,y,color,label){
    ctx.strokeStyle=color; ctx.fillStyle=color;
    ctx.beginPath(); ctx.moveTo(x,y-14); ctx.lineTo(x,y-2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x,y-2); ctx.lineTo(x-6,y-8); ctx.moveTo(x,y-2); ctx.lineTo(x+6,y-8); ctx.stroke();
    ctx.beginPath(); ctx.arc(x,y,4,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#000'; ctx.font='12px system-ui'; ctx.fillText(label, x+6, y-16);
  }
  function drawPick(axis, pos, color, label){
    let pxCoord=0, pyCoord=0;
    if(axis==='X'){ pxCoord=pos; pyCoord=0; }
    else if(axis==='Y'){ if(plane==='XY'){ pxCoord=0; pyCoord=pos; } else { pxCoord=0; pyCoord=0; } }
    else if(axis==='Z'){ if(plane==='XZ'){ pxCoord=0; pyCoord=pos; } else { pxCoord=0; pyCoord=0; } }
    const topY=rect.y+10;
    const pillX = (label==='L') ? rect.x+12 : rect.x+152;
    const pillW = 140;
    const pillText = (label==='L') ? ('Left pick ('+axis+')') : ('Right pick ('+axis+')');
    drawTopPill(pillX, topY-8, pillW, 20, color, pillText);
    drawLeader(pillX + pillW/2, topY+12, mapX(pxCoord), mapY(pyCoord), color);
    drawPickMarker(mapX(pxCoord), mapY(pyCoord), color, label);
  }
  function drawPickWorld(P, color, label){
  const pxCoord = P[0];
  const pyCoord = (plane==='XY') ? P[1] : P[2];

  const topY=rect.y+10;
  const pillX = (label==='L') ? rect.x+12 : rect.x+152;
  const pillW = 140;
  const pillText = (label==='L') ? ('Left pick') : ('Right pick');

  drawTopPill(pillX, topY-8, pillW, 20, color, pillText);
  drawLeader(pillX + pillW/2, topY+12, mapX(pxCoord), mapY(pyCoord), color);
  drawPickMarker(mapX(pxCoord), mapY(pyCoord), color, label);
}

 drawPickWorld(picks.PleftW,  COLORS.pickLeft,  'L');
drawPickWorld(picks.PrightW, COLORS.pickRight, 'R');

  // 4-pick dots
if (picks && picks.FOUR && picks.FOUR.picks && picks.FOUR.picks.list) {
  for (const pk of picks.FOUR.picks.list) {
    let pxCoord = 0, pyCoord = 0;
    if (pk.axis === 'X') { pxCoord = pk.pos; pyCoord = 0; }
    else if (pk.axis === 'Y' && plane === 'XY') { pxCoord = 0; pyCoord = pk.pos; }
    else if (pk.axis === 'Z' && plane === 'XZ') { pxCoord = 0; pyCoord = pk.pos; }
    else { continue; }
    drawPickDot(mapX(pxCoord), mapY(pyCoord), pk.color, pk.label);
  }
}
  // CG bullseye
  if (cgWorld){
    const cgX = cgWorld[0];
    const cgY = (plane==='XY') ? cgWorld[1] : cgWorld[2];
    drawCGBullseye(mapX(cgX), mapY(cgY), 'CG');
  }

  // border
  ctx.strokeStyle='#cfd4d9'; ctx.lineWidth=1; ctx.strokeRect(rect.x,rect.y,rect.w,rect.h);
}

/* ---------- big roll dial ---------- */
function drawRollDial(cx, cy, r, targetDeg){
  ctx.strokeStyle = COLORS.roll; ctx.lineWidth=3;
  ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();

  ctx.strokeStyle='#999'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx, cy-r); ctx.stroke();

  const a0 = -Math.PI/2; // up is 0°
  const a1 = a0 + (targetDeg * Math.PI/180);
  ctx.fillStyle='rgba(91,192,255,0.25)';
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,r,a0,a1, targetDeg<0); ctx.closePath(); ctx.fill();

  ctx.strokeStyle=COLORS.roll; ctx.lineWidth=3;
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx + r*Math.cos(a1), cy + r*Math.sin(a1)); ctx.stroke();

  ctx.fillStyle='#000'; ctx.font='14px system-ui'; ctx.fillText('Set Pipe Roll', cx-42, cy-r-22);
  ctx.font='18px system-ui'; ctx.fillText((targetDeg>=0?'+':'')+targetDeg.toFixed(1)+'°', cx-24, cy+8);
  ctx.font='12px system-ui'; ctx.fillText('(+Y)', cx-8, cy-r-12);
  ctx.fillText('(−Y)', cx-12, cy+r+2);
}
</script>
</body>
</html>
