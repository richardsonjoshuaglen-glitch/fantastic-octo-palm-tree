<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Complex COG Rigging Calculator — v11.01 (3D split, two bights, guards)</title>
<style>
  :root{
    --bg:#ffffff; --ink:#111; --panel:#f8f9fa; --border:#e9ecef; --accent:#0d6efd;
    --roll:#5bc0ff; --pickL:#ffd60a; --pickR:#32cd32; --anchor:#94a3b8;
  }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:16px; color:var(--ink); background:var(--bg); }
  h1 { font-size:20px; margin:0 0 10px; display:flex; align-items:center; gap:10px;}
  .badge { display:inline-block; padding:2px 8px; border-radius:999px; background:#d1e7dd; color:#0f5132; font-weight:700; font-size:12px; }
  fieldset { border:1px solid #ccc; border-radius:10px; margin:10px 0; padding:10px 12px; }
  legend { padding:0 6px; font-weight:600; }
  label { display:block; margin:6px 0 2px; font-size:14px; }
  .inline { display:flex; align-items:center; gap:8px; }
  select, input[type="number"] { width:100%; font-size:16px; padding:10px 12px; box-sizing:border-box; border-radius:8px; border:1px solid #cfd4d9; }
  .row { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
  .row3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px;}
  .btn { display:inline-block; padding:10px 12px; margin:8px 6px 0 0; border-radius:10px; background:var(--accent); color:#fff; border:none; font-size:16px; cursor:pointer; }
  .btn.secondary { background:#6c757d; }
  .items { margin-top:6px; }
  .item { padding:8px; border:1px dashed #999; border-radius:8px; margin-bottom:8px; font-size:14px; }
  .hint { color:#555; font-size:13px; }
  #sheet { width:100%; max-width:1000px; background:#fff; border:1px solid #ddd; border-radius:8px; display:block; }
  .out { background:var(--panel); padding:12px; border-radius:10px; border:1px solid var(--border); line-height:1.5; font-size:15px; }
  .out h3 { margin:6px 0; font-size:16px; }
  .pill { display:inline-block; padding:2px 8px; border-radius:999px; font-weight:600; font-size:12px; color:#000; vertical-align:baseline; }
  .pill.left { background: var(--pickL); }
  .pill.right{ background: var(--pickR); }
  .pill.roll { background: var(--roll); }
  .muted { color:#444; font-size:13px; }
  #debug { margin-top:6px; font-size:12px; color:#b00020; white-space:pre-wrap; border:1px dashed #ddd; padding:6px; border-radius:6px;}
  .axis-key { font-size:12px; background:#f6f8fa; border:1px solid #e0e0e0; border-radius:8px; padding:8px; line-height:1.35; }
  .axis-key strong{display:inline-block; width:2.4em;}
  .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .combo { width:100%; border-collapse:separate; border-spacing:0; margin-top:8px; }
  .combo th, .combo td { border:1px solid var(--border); padding:8px; text-align:left; }
  .combo th { background:#eef2f7; }
  .warn { background:#fff3cd; border:1px solid #ffe69c; padding:6px 10px; border-radius:8px; display:inline-block; font-size:13px; }
/* Layman output box */
#layman{
  background:#fff9db;
  border:1px solid #ffe066;
  padding:10px;
  border-radius:10px;
  margin-top:8px;
  font-size:14px;
  line-height:1.45;
}
</style>
</head>
<body>
<h1>Rigging CG Helper — v11.01 <span class="badge" id="badge">JS Loaded</span></h1>

<fieldset>
  <legend>Pick setup</legend>
  <div class="row3">
    <label>Pick mode
      <select id="pickMode">
  <option value="4" selected>4-point (two chokers)</option>
  <option value="2">2-point (XY only)</option>
</select>
<div class="hint">2-point = XY only. If Z shows up in the math, you’ll be warned to switch back to 4-point.</div>
    </label>
    <label>Pick axes
      <select id="pickAxes">
        <option value="AUTO" selected>Auto</option>
        <option value="XY">X & Y</option>
        <option value="XZ">X & Z</option>
        <option value="YZ">Y & Z</option>
      </select>
    </label>
    <div>
  <label>Coupling center (in)</label>
  <div class="row">
    <input id="cX" type="number" value="0" aria-label="Coupling center X">
    <input id="cY" type="number" value="0" aria-label="Coupling center Y">
  </div>
  <input id="cZ" type="number" value="0" aria-label="Coupling center Z" style="margin-top:6px;">
</div>
    <div class="axis-key">
      <div><strong>X+</strong> left → right</div>
      <div><strong>Y+</strong> toward you &nbsp;&nbsp; <strong>Y−</strong> away from you</div>
      <div><strong>Z+</strong> up &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Z−</strong> down</div>
    </div>
  </div>
  <label class="inline" style="align-items:center; gap:8px; margin-top:8px;">
    <input id="togglePrevCoupling" type="checkbox"> Distances from previous coupling center (axis=0)
  </label>
  <div class="muted">Output shows **pick points** and the matching **20′ basket split** together. First leg corresponds to the **first axis**.</div>
</fieldset>

<fieldset>
  <legend>Add item</legend>
  <div class="row">
    <label>Item type
      <select id="itemType">
  <option value="P">24&quot; pipe (per-inch)</option>
  <option value="V">24&quot; valve (regular)</option>
  <option value="E">24&quot; 90° elbow (LR arc)</option>
  <option value="F">24&quot; 45° elbow (LR arc)</option>
  <option value="T">24&quot; tee (plain)</option>
  <option value="W">24&quot; tee with valve</option>
  <option value="G">Single 90 with valve</option>
  <option value="X">Custom per-inch</option>
  <option value="Y">Custom fixed</option>
</select>
    </label>
    <label>Orientation (layman)
      <select id="orient">
        <option value="Xp" selected>Right (X+)</option>
        <option value="Xm">Left (X−)</option>
        <option value="Yp">Toward You (Y+)</option>
        <option value="Ym">Away From You (Y−)</option>
        <option value="Zp">Up (Z+)</option>
        <option value="Zm">Down (Z−)</option>
      </select>
    </label>
  </div>

  <div class="row" id="lenRow" style="display:block">
    <label>Length (in)
      <input id="lenIn" type="number" inputmode="decimal" value="60">
    </label>
    <label id="wpiLabel">Weight per inch (lb/in)
      <input id="wpi" type="number" inputmode="decimal" value="8.2">
    </label>
  </div>

  <div class="row" id="fixedRow" style="display:none">
    <label>Total weight (lb)
      <input id="fixedW" type="number" inputmode="decimal" value="0">
    </label>
    <label>Effective length along chosen axis (in)
      <input id="fixedL" type="number" inputmode="decimal" value="0">
    </label>
  </div>

  <div id="single90Row" class="row" style="display:none">
    <label>Straight before 90 (in)
      <input id="s90_before" type="number" inputmode="decimal" value="0">
    </label>
    <label>Extra straight AFTER 90 (in)
      <input id="s90_after" type="number" inputmode="decimal" value="0">
    </label>
    <label>Valve type
      <select id="s90_vtype">
        <option value="S">Standard</option>
      </select>
    </label>
  </div>

  <button class="btn" id="addBtn" type="button">Add item</button>
  <button class="btn secondary" id="removeLastBtn" type="button">Remove last item</button>
  <button class="btn secondary" id="clearBtn" type="button">Clear list</button>

  <div class="items" id="items"></div>
  <div id="debug">debug: (none)</div>
</fieldset>

<button class="btn" id="computeBtn" type="button">Compute + Draw</button>
<button class="btn secondary" id="downloadBtn" type="button" disabled>Download PNG</button>

<fieldset>
  <legend>Output (combined)</legend>
  <div id="summary" class="out">Add items and click “Compute + Draw”.</div>
  <div id="layman">Plain-English steps will appear here.</div>
  <div class="muted">Legend: <span class="pill left">Left</span> <span class="pill right">Right</span> <span class="pill roll">Roll</span></div>
</fieldset>

<fieldset>
  <legend>Drawings</legend>
  <canvas id="sheet"></canvas>
  <div class="muted">Plan (X–Y) & Elevation (X–Z). Labels group by <b>Left</b>/<b>Right</b>.</div>
</fieldset>

<script>
(function(){
  var b=document.getElementById('badge');
  if(b) b.textContent='JS Loaded v11.01';
})();
if(!window.__rig_v1101_wired){
  window.__rig_v1101_wired = true;
  
  /* Canvas / HiDPI */
  function setupCanvas(canvas, cssW, cssH) {
    cssW = cssW || 1000; cssH = cssH || 1200;
    var dpr = window.devicePixelRatio || 1;
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width  = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    var ctx = canvas.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.textBaseline = 'top';
    return ctx;
  }

  /* Constants */
  var W_PER_IN_DEFAULT = 8.2;
  // 24" fittings (centerline dimensions)
// Long-radius 90° elbow: R = 1.5D = 36", arc length = (π/2)·R ≈ 56.55"
var W_EL90 = 475.0;
var R_EL90 = 36.0;
var S_EL90_ARC = Math.PI * 0.5 * R_EL90;   // 56.55 in used for CG/weight

// 45° elbow: centerline arc length = (π/4)·R, using same LR radius for 24"
var W_EL45 = 240.0;
var R_EL45 = 36.0;
var S_EL45_ARC = Math.PI * 0.25 * R_EL45;  // 28.27 in
  var W_VALVE_BODY=451.0, L_VALVE_STD=12.0;
  var W_TEE_BODY=477.0, L_TEE=20.0;
  var LEG_TOTAL_IN = 240.0;      // 20'
  var LEG_MIN_IN   = 12.0;       // < 12" => needs more rigging
  var EPS = 1e-6;

  /* Colors */
  var COLORS = {
  axisX:'#d12222', axisY:'#2a9d2a', axisZ:'#1f6feb',
  P:'#666666', E:'#2aa198', F:'#2aa198',
  V:'#ff9100', C:'#8e44ad',
  T:'#d33682', W:'#d33682', G:'#2aa198',
  X:'#8d6e63', Y:'#8d6e63',
  pickLeft: (getComputedStyle(document.documentElement).getPropertyValue('--pickL') || '#ffd60a').trim(),
  pickRight:(getComputedStyle(document.documentElement).getPropertyValue('--pickR') || '#32cd32').trim(),
  pipeBand:'rgba(100,100,100,0.18)',
  centerline:'#000',
  anchor:(getComputedStyle(document.documentElement).getPropertyValue('--anchor') || '#94a3b8').trim(),
  arrow:'#00e676'        // <— NEW: bright green bi-directional arrows
};

  /* Helpers */
  var ORIENTS={ Xp:[1,0,0], Xm:[-1,0,0], Yp:[0,1,0], Ym:[0,-1,0], Zp:[0,0,1], Zm:[0,0,-1] };
  function roundHalf(x){ return Math.round(x*2)/2; }
  function fmtFtIn(x){
    var v=roundHalf(x);
    var ft=Math.floor(v/12);
    var rem=v-ft*12;
    var whole=Math.floor(rem);
    var frac=rem - whole;
    var fracStr = (Math.abs(frac) < 1e-6) ? '' : (Math.abs(frac-0.5)<1e-6 ? '-1/2' : '' );
    var inch = whole + (fracStr||'') + '"';
    var ORIENT_LABELS = {
  Xp:'Right (X+)', Xm:'Left (X−)',
  Yp:'Toward You (Y+)', Ym:'Away From You (Y−)',
  Zp:'Up (Z+)', Zm:'Down (Z−)'
};
    return ft? (ft+"' "+inch) : inch;
  }
  function fmtInches(x){ return (Math.round(x*10)/10).toFixed(1) + '"'; }
  function vEq(a,b){return a[0]===b[0]&&a[1]===b[1]&&a[2]===b[2];}
  function el(id){ return document.getElementById(id); }

  /* State */
  var items=[], segments=[], marks=[];
var ctx, sheet, summaryDiv, itemsDiv, debugDiv, laymanDiv;
var pickModeEl, pickAxesEl, togglePrevCouplingEl, cXEl, cYEl, cZEl;
var itemTypeEl, orientEl, lenRow, wpiEl, wpiLabel, lenInEl, fixedRow, fixedWEl, fixedLEl;
var single90Row;
  /* UI helpers */
  function updateDetailRows(){
    var t=itemTypeEl.value;
    lenRow.style.display='none'; fixedRow.style.display='none'; single90Row.style.display='none';
    if(t==='P'||t==='X'){ lenRow.style.display='grid'; wpiLabel.style.display='block'; }
    if(t==='Y'){ fixedRow.style.display='grid'; }
    if(t==='G'){ single90Row.style.display='grid'; }
    if(t!=='X') wpiEl.value=W_PER_IN_DEFAULT;
  }
  function addItemSummary(text){
    var d=document.createElement('div'); d.className='item'; d.textContent=text; itemsDiv.appendChild(d);
  }
  function resetAll(){
    items=[]; segments=[]; marks=[];
    itemsDiv.innerHTML=''; summaryDiv.innerHTML='';
    ctx && ctx.clearRect(0,0,sheet.width,sheet.height);
    debugDiv.textContent='debug: reset';
  }
  function removeLast(){
  if(items.length===0) return;
  items.pop();                           // drop from data
  if(itemsDiv.lastElementChild){         // drop the visual card
    itemsDiv.removeChild(itemsDiv.lastElementChild);
  }
  rebuildGeometry();
  redrawDebug();
  summaryDiv.innerHTML='';               // clear stale summary so user recomputes
  laymanDiv.innerHTML='Plain-English steps will appear here.';
  ctx && ctx.clearRect(0,0,sheet.width,sheet.height);
  el('downloadBtn').disabled = true;
}

  /* Geometry */
  function getCurrentEnd(){ return segments.length===0?[0,0,0]:segments[segments.length-1].end.slice(); }
  function pushSegment(tCode,dir,L,labelIdx,drawCode,countJoint){
    var start=getCurrentEnd(); var end=[ start[0]+dir[0]*L, start[1]+dir[1]*L, start[2]+dir[2]*L ];
    segments.push({tCode, start, end, drawCode:drawCode||tCode, countJoint: (countJoint!==false) });
    if(labelIdx!=null){
      var mid=[(start[0]+end[0])/2,(start[1]+end[1])/2,(start[2]+end[2])/2];
      marks.push([labelIdx,mid[0],mid[1],mid[2]]);
    }
  }
  function itemWeightText(idx, label, L, W){
    return idx+'. '+label+' L='+L.toFixed(1)+' in, W='+W.toFixed(1)+' lb';
  }
  function addItem(){
    try{
      var t=itemTypeEl.value; var idx=items.length+1;
      var okey=orientEl.value; var ovec=ORIENTS[okey]||[1,0,0];
      function placeLinear(name,L,W,xcgLocal,tCode){
        L=Math.max(0, Number(L)||0);
        if(xcgLocal==null) xcgLocal=L/2;
        items.push({name,length:L,weight:W,xcg_local:xcgLocal,tCode,orientVec:ovec});
        addItemSummary(itemWeightText(idx, name, L, W) + '  •  Dir: ' + (ORIENT_LABELS[okey]||okey));
        rebuildGeometry(); redrawDebug();
      }
      if(t==='P'){ var L=Number(lenInEl.value)||0, wpi=Number(wpiEl.value)||W_PER_IN_DEFAULT; var W=wpi*L; placeLinear('24\" pipe (per-inch)',L,W,null,'P'); }
      else if(t==='X'){ var Lx=Number(lenInEl.value)||0, wpiX=Number(wpiEl.value)||W_PER_IN_DEFAULT; var WX=wpiX*Lx; placeLinear('Custom per-inch',Lx,WX,null,'X'); }
      else if(t==='Y'){ var WY=Number(fixedWEl.value)||0, LY=Number(fixedLEl.value)||0; placeLinear('Custom fixed',LY,WY,null,'Y'); }
      else if(t==='V'){ var LV=L_VALVE_STD, WV=W_VALVE_BODY; placeLinear('24\" valve (regular)',LV,WV,LV/2,'V'); }
      else if(t==='E'){ var LE=S_EL90_ARC, WE=W_EL90; placeLinear('24" 90° elbow (LR arc)', LE, WE, LE/2, 'E'); }
      else if(t==='F'){ var LF=S_EL45_ARC, WF=W_EL45; placeLinear('24" 45° elbow (LR arc)', LF, WF, LF/2, 'F'); }
      else if(t==='T'){ var LT=L_TEE, WT=W_TEE_BODY; placeLinear('24\" tee (plain)',LT,WT,LT/2,'T'); }
      else if(t==='W'){ var LW=L_TEE, WW=W_TEE_BODY+W_VALVE_BODY; placeLinear('24\" tee with valve',LW,WW,LW/2,'W'); }
      else if(t==='G'){
  var LG=S_EL90_ARC, WG=W_EL90+W_VALVE_BODY;
  placeLinear('Single 90 with valve', LG, WG, LG/2, 'G');
}
    }catch(err){ debugDiv.textContent = 'debug: Add item failed: ' + (err && err.message ? err.message : err); }
  }
  function rebuildGeometry(){
    segments=[]; marks=[];
    if(items.length===0) return;
    var dir = items[0].orientVec.slice();
    for(var i=0;i<items.length;i++){
      var it=items[i];
      var nextDir = (i<items.length-1)? items[i+1].orientVec.slice() : it.orientVec.slice();
      pushSegment(it.tCode, dir, it.length, i+1, it.tCode, true);
      if(!vEq(nextDir, dir)) dir = nextDir.slice();
    }
  }
  function redrawDebug(){ debugDiv.textContent = 'debug: items='+items.length+'; segments='+segments.length; }
  function axisExt(sel){
    var arr=[]; for(var k=0;k<segments.length;k++){ arr.push(segments[k].start[sel],segments[k].end[sel]); }
    if(arr.length===0) arr=[0];
    var min=Math.min.apply(null,arr), max=Math.max.apply(null,arr);
    return {min:min,max:max,span:(max-min)};
  }

  /* Compute + Draw */
  function computeAndDraw(){
    if(items.length===0){ alert('Add at least one item.'); return; }
var pickAxesSel = pickAxesEl.value;
var pickMode = (pickModeEl && pickModeEl.value) || '4';

    // Weighted CG at segment mids
    var totalW=0, sumX=0, sumY=0, sumZ=0;
    for(var i=0;i<items.length;i++){
      var it=items[i];
      var sg=null;
      for(var s=0;s<segments.length;s++){ if(segments[s].tCode===it.tCode){ sg=segments[s]; break; } }
      var m = sg? [(sg.start[0]+sg.end[0])/2,(sg.start[1]+sg.end[1])/2,(sg.start[2]+sg.end[2])/2] : [0,0,0];
      totalW += it.weight; sumX += it.weight*m[0]; sumY += it.weight*m[1]; sumZ += it.weight*m[2];
    }
    var cg = totalW? [sumX/totalW, sumY/totalW, sumZ/totalW] : [0,0,0];

    var ext={ X:axisExt(0), Y:axisExt(1), Z:axisExt(2) };
    function chooseAxes(){
  // If operator explicitly chose a pair, honor it (unless 2-pick forbids Z)
  if(pickMode === '2'){
    // 2-pick is XY-only
    // If the operator tries XZ or YZ we force XY and report a warning later.
    return ['X','Y'];
  }
  if(pickAxesSel==='XY'||pickAxesSel==='XZ'||pickAxesSel==='YZ'){
    return pickAxesSel.split('');
  }
  // AUTO: pick the two largest spans
  var spans=[['X',ext.X.span],['Y',ext.Y.span],['Z',ext.Z.span]].sort(function(a,b){return b[1]-a[1];});
  var axes=[]; for(var s=0;s<spans.length && axes.length<2;s++){ if(spans[s][1]>0) axes.push(spans[s][0]); }
  if(axes.length===0) axes=['X'];
  return axes;
}
    var axes=chooseAxes();

    var warnings = [];
if (pickMode === '2') {
  // If user explicitly selected a pair containing Z, flag it.
  if (pickAxesSel === 'XZ' || pickAxesSel === 'YZ') {
    warnings.push('You selected '+pickAxesSel+' while in 2-point mode. 2-point mode is XY-only; switched to XY.');
  }
  // If geometry meaningfully uses Z, also warn.
  var Z_in_play = ext.Z.span > 0.01;
  if (Z_in_play) {
    warnings.push('Z geometry detected. Switch to 4-point mode (XZ / YZ) to control level in Z.');
  }
  // Force axes to XY
  axes = ['X','Y'];
}
    function balancedPoints(axis){
      var ex=ext[axis], cgA=(axis==='X'?cg[0]:(axis==='Y'?cg[1]:cg[2]));
      var left = (ex.min + cgA)/2;
      var right = (cgA + ex.max)/2;
      left  = Math.max(ex.min, Math.min(ex.max, left));
      right = Math.max(ex.min, Math.min(ex.max, right));
      if(right<=left){ right = left + 1; }
      return {left:left, right:right, ex:ex};
    }
    var setA = balancedPoints(axes[0]);
var setB = balancedPoints(axes[1]||axes[0]);
    // Use enforced picks when computing legs:
var leftPair  = split3D('L', leftAdj.a,  leftAdj.b);
var rightPair = split3D('R', rightAdj.a, rightAdj.b);

// And also when drawing: supply LEFT/RIGHT picks per axis
var picksForDraw = [
  { axis: axes[0], picks: [leftAdj.a,  rightAdj.a],  ex: ext[axes[0]] },
  { axis: (axes[1]||axes[0]), picks: [leftAdj.b, rightAdj.b], ex: ext[(axes[1]||axes[0])] }
];

drawSheet(picksForDraw);
    var MIN_SPREAD = 24, MAX_SPREAD = 72;
var A = axes[0], B = axes[1] || axes[0];

// Left side pair (setA.left vs setB.left)
var leftAdj  = enforceSpreadPair(setA.left,  setB.left,  A, B, ext, MIN_SPREAD, MAX_SPREAD);
// Right side pair (setA.right vs setB.right)
var rightAdj = enforceSpreadPair(setA.right, setB.right, A, B, ext, MIN_SPREAD, MAX_SPREAD);

// Append any notes to warnings
if (leftAdj.note)  warnings.push('Left: '  + leftAdj.note);
if (rightAdj.note) warnings.push('Right: ' + rightAdj.note);
   
    /* Bight placement (two bights) by projection of CG into pick plane */
    function bightForSide(side){ // 'L' or 'R' (same placement rule; two conceptual bights)
      if(axes[0]==='X' && axes[1]==='Y'){ return [cg[0], cg[1], 0]; }
      if(axes[0]==='Y' && axes[1]==='X'){ return [cg[0], cg[1], 0]; }
      if(axes[0]==='X' && axes[1]==='Z'){ return [cg[0], 0, cg[2]]; }
      if(axes[0]==='Z' && axes[1]==='X'){ return [cg[0], 0, cg[2]]; }
      if(axes[0]==='Y' && axes[1]==='Z'){ return [0, cg[1], cg[2]]; }
      if(axes[0]==='Z' && axes[1]==='Y'){ return [0, cg[1], cg[2]]; }
      // Fallback: project to first axis plane
      return [cg[0], cg[1], 0];
    }

    /* 3-D straight-line distances from bight to each axis pick */
    function pointOnAxis(axis,val){ return (axis==='X')?[val,0,0]:(axis==='Y')?[0,val,0]:[0,0,val]; }
    function d3(p,q){ var dx=p[0]-q[0], dy=p[1]-q[1], dz=p[2]-q[2]; return Math.sqrt(dx*dx+dy*dy+dz*dz); }

    function split3D(side, pickA, pickB){ // side 'L' or 'R', enforced picks
  var BLBR = bightForSide(side);
  var PA = pointOnAxis(axes[0], pickA);
  var PB = pointOnAxis(axes[1]||axes[0], pickB);
  var rA = Math.max(EPS, d3(BLBR, PA));
  var rB = Math.max(EPS, d3(BLBR, PB));
  var sum = rA + rB;
  var a_raw = LEG_TOTAL_IN * (rA / sum);
  var b_raw = LEG_TOTAL_IN - a_raw;
  // ... (rest unchanged);

      // Round to 0.5", then enforce exact 240" by nudging the longer leg (ties -> axis-A)
      var a = roundHalf(a_raw), b = roundHalf(b_raw);
      var delta = LEG_TOTAL_IN - (a + b);
      if(Math.abs(delta) >= 0.25 - 1e-9){ // only if off by >= 0.25" due to rounding
        if(a >= b) a += delta; else b += delta;
        a = roundHalf(a); b = roundHalf(b);
      } else if(Math.abs(delta) > 1e-9){
        if(a >= b) a += delta; else b += delta;
      }

      var needsMore = (a < LEG_MIN_IN) || (b < LEG_MIN_IN);
     return {
  a:a, b:b, sum:roundHalf(a+b),
  pickA: pickA, pickB: pickB,
  rA:rA, rB:rB, needsMore: needsMore
}; 
      return {a:a, b:b, sum:roundHalf(a+b), pickA:pickA, pickB:pickB, rA:rA, rB:rB, needsMore:needsMore};
    }

    var leftPair  = split3D('L', leftAdj.a,  leftAdj.b);
    var rightPair = split3D('R', rightAdj.a, rightAdj.b);

    function clamp(x,min,max){ return Math.max(min, Math.min(max, x)); }
function signLike(x, ref){ return (ref>=0? 1 : -1) * Math.abs(x); }

/**
 * Enforce 24"–72" distance between the two picks on one side.
 * Keeps the A:B ratio by scaling both picks from the origin (0,0),
 * then respects each axis's allowable range; if limits block the target,
 * snaps to the nearest feasible pair and returns a warning note.
 *
 * @param {number} pA - current pick on primary axis (absolute inches)
 * @param {number} pB - current pick on secondary axis (absolute inches)
 * @param {string} A  - 'X'|'Y'|'Z' (primary axis key)
 * @param {string} B  - 'X'|'Y'|'Z' (secondary axis key)
 * @param {object} ext - { X:{min,max}, Y:{min,max}, Z:{min,max} }
 * @param {number} MIN - minimum spread (in)
 * @param {number} MAX - maximum spread (in)
 * @returns {{a:number,b:number, note:string|null}}
 */
function enforceSpreadPair(pA, pB, A, B, ext, MIN, MAX){
  var d = Math.hypot(pA, pB);
  if (d < 1e-9){
    // Edge case: both at origin—nudge to MIN along whichever axis has room
    var roomA = Math.max(Math.abs(ext[A].min), Math.abs(ext[A].max));
    var roomB = Math.max(Math.abs(ext[B].min), Math.abs(ext[B].max));
    if (roomA >= MIN) return {a: signLike(MIN, ext[A].max>=0?+1:-1), b: 0, note: 'Spread forced from origin'};
    if (roomB >= MIN) return {a: 0, b: signLike(MIN, ext[B].max>=0?+1:-1), note: 'Spread forced from origin'};
    // Neither axis has MIN—push to max feasible on the larger room axis
    if (roomA >= roomB) return {a: signLike(roomA, ext[A].max>=0?+1:-1), b: 0, note: 'Spread limited by axis range'};
    return {a: 0, b: signLike(roomB, ext[B].max>=0?+1:-1), note: 'Spread limited by axis range'};
  }

  var target = clamp(d, MIN, MAX);
  var scale  = target / d;
  var a = pA * scale, b = pB * scale;

  // Clamp to each axis's bounds first pass
  var a1 = clamp(a, ext[A].min, ext[A].max);
  var b1 = clamp(b, ext[B].min, ext[B].max);

  // If neither hit a clamp hard, we’re done
  if (Math.abs(a1-a)<1e-9 && Math.abs(b1-b)<1e-9){
    return {a:a1, b:b1, note: null};
  }

  // Second pass: if one axis hit a limit, solve the other to keep target distance
  function trySolveKeepTarget(lockedA, valA, wantTarget, refB, Bkey){
    var neededB = Math.sqrt(Math.max(0, wantTarget*wantTarget - valA*valA));
    // Maintain original sign of B
    neededB = signLike(neededB, refB);
    return clamp(neededB, ext[Bkey].min, ext[Bkey].max);
  }
  var a2 = a1, b2 = b1;
  if (Math.abs(a1-a) >= 1e-9){
    b2 = trySolveKeepTarget(true, a1, target, pB, B);
  }
  if (Math.abs(b1-b) >= 1e-9){
    a2 = trySolveKeepTarget(true, b1, target, pA, A); // reuse function by symmetry
  }

  // If still off, accept nearest feasible and annotate
  var d2 = Math.hypot(a2, b2);
  if (d2 < MIN || d2 > MAX){
    return {a:a2, b:b2, note:'Spread limited by geometry ('+Math.round(d2)+'″) — check clearances or switch pick axes.'};
  }
  return {a:a2, b:b2, note: null};
}
    /* Output (combined) */
    function distLabel(axis, val){
  if(togglePrevCouplingEl.checked){
    var cx = Number(cXEl && cXEl.value || 0),
        cy = Number(cYEl && cYEl.value || 0),
        cz = Number(cZEl && cZEl.value || 0);
    if(axis==='X') return fmtInches(val - cx);
    if(axis==='Y') return fmtInches(val - cy);
    return fmtInches(val - cz);
  }else{
    return fmtInches(val - ext[axis].min);
  }
}

    var html='';
    html += '<h3>Rigging Summary</h3><ul>';
    html += '<li>Total weight: <b>'+totalW.toFixed(1)+' lb</b></li>';
    html += '<li>CG (true 3D): X=<b>'+cg[0].toFixed(2)+' in</b>, Y=<b>'+cg[1].toFixed(2)+' in</b>, Z=<b>'+cg[2].toFixed(2)+' in</b></li>';
    html += '</ul>';

    html += '<h3>Chokers & 20′ Basket — Combined</h3>';
    html += '<div class="muted mono">First leg ↔ <b>'+axes[0]+'</b> pick • Second leg ↔ <b>'+(axes[1]||axes[0])+'</b> pick.</div>';
    html += '<table class="combo mono"><thead><tr><th>Side</th><th>Pick '+axes[0]+' (offset)</th><th>Pick '+(axes[1]||axes[0])+' (offset)</th><th>Legs (sum = 20′)</th><th>Status</th></tr></thead><tbody>';

    function row(sideLabel, pair){
      var p1 = pair.pickA, p2 = pair.pickB;
      var aTxt = fmtFtIn(pair.a), bTxt = fmtFtIn(pair.b);
      var status = pair.needsMore ? '<span class="warn">NEEDS MORE RIGGING (leg &lt; 12″)</span>' : 'OK';
      return '<tr>'
        + '<td><span class="pill '+(sideLabel==='Left'?'left':'right')+'">'+sideLabel+'</span></td>'
        + '<td>'+axes[0]+': '+p1.toFixed(2)+' in &nbsp;('+distLabel(axes[0], p1)+')</td>'
        + '<td>'+(axes[1]||axes[0])+': '+p2.toFixed(2)+' in &nbsp;('+distLabel((axes[1]||axes[0]), p2)+')</td>'
        + '<td>'+aTxt+' + '+bTxt+'</td>'
        + '<td>'+status+'</td>'
        + '</tr>';
    }

    html += row('Left', leftPair);
    html += row('Right', rightPair);
    html += '</tbody></table>';

    // Roll info (unchanged simple model using Y)
    var PIPE_R_IN = 12;
    var roll_deg = (PIPE_R_IN>0)? (Math.asin(Math.max(-1,Math.min(1, cg[1]/PIPE_R_IN)))*180/Math.PI) : 0;
    var roll_side=cg[1]>0?'toward +Y':(cg[1]<0?'toward -Y':'no roll needed');
    var arc_in=PIPE_R_IN*(Math.abs(roll_deg)*Math.PI/180);
    html += '<h3>Roll</h3><ul>';
    html += '<li><span class="pill roll">Roll</span> chokers: ~'+roll_deg.toFixed(1)+'° '+roll_side+'</li>';
    html += '<li><span class="pill roll">Roll</span> circumference offset per choker: '+fmtFtIn(arc_in)+'</li>';
    html += '</ul>';
    if (warnings.length){
  html += '<div class="warn" style="margin-top:6px"><b>Heads up:</b> ' + warnings.join(' ') + '</div>';
}
    summaryDiv.innerHTML = html;
/* Layman steps — simple, numbered, and literal */
function fmtFtInSigned(x){
  var s = x<0 ? '-' : '';
  var v = Math.abs(x);
  var ft = Math.floor(v/12);
  var rem = v - ft*12, whole = Math.floor(rem), frac = rem - whole;
  var fracStr = (Math.abs(frac)<1e-6)? '' : (Math.abs(frac-0.5)<1e-6? '-1/2' : '');
  var inch = whole + (fracStr||'') + '"';
  return s + (ft? (ft+"' "+inch) : inch);
}
function fmtBoth(x){ return fmtFtInSigned(x) + ' (' + (Math.round(x*10)/10).toFixed(1) + '")'; }

function offsetValue(axis, val){
  if(togglePrevCouplingEl.checked){
    var cx = Number(cXEl.value||0), cy = Number(cYEl.value||0), cz = Number(cZEl.value||0);
    if(axis==='X') return val - cx;
    if(axis==='Y') return val - cy;
    return val - cz; // Z
  }else{
    return val - ext[axis].min;
  }
}

function okBad(bool){ return bool ? 'OK' : 'ADJUST'; }

function laymanSide(title, pair){
  // Pretty values
  var pickA_here  = fmtBoth(pair.pickA);
  var pickB_here  = fmtBoth(pair.pickB);
  var offA_here   = fmtBoth(offsetValue(axes[0], pair.pickA));
  var offB_here   = fmtBoth(offsetValue((axes[1]||axes[0]), pair.pickB));
  var legA_hereFI = fmtFtInSigned(pair.a) + ' (' + pair.a.toFixed(1) + '")';
  var legB_hereFI = fmtFtInSigned(pair.b) + ' (' + pair.b.toFixed(1) + '")';

  // Spread check (distance between the two pick points for this side in the pick plane)
  var spread_in   = Math.hypot(pair.pickA, pair.pickB);
  var spread_txt  = fmtBoth(spread_in);
  var spread_ok   = spread_in >= 24 && spread_in <= 72;   // 2 ft–6 ft
  var short_leg   = pair.needsMore; // any leg < 12"

  // 5-step recipe, no jargon
  var html = '';
  html += '<h4>'+title+' choker ('+axes[0]+' / '+(axes[1]||axes[0])+')</h4>';
  html += '<ol>';
  html += '  <li><b>Mark the picks</b><br>';
  html += '      • On <b>'+axes[0]+'</b>: '+pickA_here+' &nbsp;<span class="muted">[offset '+offA_here+']</span><br>';
  html += '      • On <b>'+(axes[1]||axes[0])+'</b>: '+pickB_here+' &nbsp;<span class="muted">[offset '+offB_here+']</span></li>';
  html += '  <li><b>Cut the legs</b><br>';
  html += '      • <b>'+axes[0]+'-leg</b>: '+legA_hereFI+'<br>';
  html += '      • <b>'+(axes[1]||axes[0])+'-leg</b>: '+legB_hereFI+'<br>';
  html += '      <span class="muted">Two legs together = 20′ total.</span></li>';
  html += '  <li><b>Build the choker</b>: run both legs through the bight, choke the pipe. <b>Keep the bight fixed</b> while you adjust.</li>';
  html += '  <li><b>Hook in</b>: clip each leg to its mark you made above on the two axes.</li>';
  html += '  <li><b>Quick checks</b><br>';
  html += '      • <b>Spread</b> between the two legs on this side: '+spread_txt+' — <b>'+okBad(spread_ok)+'</b> (want 2′–6′)<br>';
  html += '      • <b>Short-leg?</b> '+(short_leg ? '<span class="warn">One leg &lt; 12″ — add more rigging or re-pick.</span>' : 'No, both ≥ 12″')+'</li>';
  html += '</ol>';
  return html;
}

// Global roll note (same for both sides)
var PIPE_R_IN = 12;
var roll_deg = (PIPE_R_IN>0)? (Math.asin(Math.max(-1,Math.min(1, cg[1]/PIPE_R_IN)))*180/Math.PI) : 0;
var roll_side = cg[1]>0 ? 'toward +Y (toward you)' : (cg[1]<0 ? 'toward -Y (away from you)' : 'no roll needed');
var arc_in = PIPE_R_IN*(Math.abs(roll_deg)*Math.PI/180);

// Warnings bundled (mode + spread limit notes, etc.)
var warnBits = [];
if (warnings && warnings.length) warnBits = warnBits.concat(warnings);
var warnHTML = warnBits.length ? ('<div class="warn"><b>Heads up:</b> '+warnBits.join(' ')+'</div>') : '';

// Final Layman block
laymanDiv.innerHTML =
  '<h3>Layman Steps</h3>' +
  laymanSide('Left', leftPair) +
  laymanSide('Right', rightPair) +
  '<h4>Roll (if needed)</h4>' +
  '<ul>' +
  '  <li>Roll chokers about <b>'+Math.abs(roll_deg).toFixed(1)+'°</b> '+roll_side+'.</li>' +
  '  <li>That’s roughly <b>'+fmtFtInSigned(arc_in)+'</b> of circumference shift on each choker.</li>' +
  '</ul>' +
  warnHTML;
    
    // Draw
    drawSheet([{axis:axes[0],picks:[setA.left,setA.right],ex:ext[axes[0]]},
               {axis:(axes[1]||axes[0]),picks:[setB.left,setB.right],ex:ext[(axes[1]||axes[0])]}]);
    el('downloadBtn').disabled=false;
  }

  /* Drawing */
  function drawSheet(picksets){
    ctx=setupCanvas(sheet, 1000, 1200);
    var W=1000,H=1200,pad=28;
    var secH=Math.floor((H-pad*4)/2);
    var planRect={x:pad,y:pad,w:W-2*pad,h:secH};
    var elevRect={x:pad,y:pad*2+secH,w:W-2*pad,h:secH};

    ctx.fillStyle='#fff'; ctx.fillRect(0,0,W,H);

    var verts=[[0,0,0]];
    for(var i=0;i<segments.length;i++){ verts.push( segments[i].end.slice() ); }
    var px=verts.map(v=>v[0]), py=verts.map(v=>v[1]), pz=verts.map(v=>v[2]);

    drawProjection(planRect,px,py,'Plan (X–Y)',picksets,'XY');
    drawProjection(elevRect,px,pz,'Elevation (X–Z)',picksets,'XZ');
  }



function drawProjection(rect,px,py,title,picksets,plane){
  var minX=Math.min.apply(null, px.concat([0])), maxX=Math.max.apply(null, px.concat([1]));
  var minY=Math.min.apply(null, py.concat([-1])), maxY=Math.max.apply(null, py.concat([1]));

  var pad=46;
  var sx=(rect.w-pad*2)/((maxX-minX)||1);
  var sy=(rect.h-pad*2)/((maxY-minY)||1);
  var s=Math.min(sx,sy);
  function mapX(x){ return rect.x+pad+(x-minX)*s; }
  function mapY(y){ return rect.y+rect.h-pad-(y-minY)*s; }

  ctx.fillStyle='#000'; ctx.font='20px system-ui';
  ctx.fillText(title, rect.x, rect.y-6);

  // Axes
  ctx.lineWidth=2;
  ctx.strokeStyle=COLORS.axisX; ctx.beginPath(); ctx.moveTo(mapX(minX), mapY(0)); ctx.lineTo(mapX(maxX), mapY(0)); ctx.stroke();
  ctx.strokeStyle=(plane==='XY')?COLORS.axisY:COLORS.axisZ;
  var x0=mapX(0); ctx.beginPath(); ctx.moveTo(x0,mapY(minY)); ctx.lineTo(x0,mapY(maxY)); ctx.stroke();

  var thickness=Math.min(30, Math.max(8, s*24*0.6));
  ctx.lineCap='round';

  // Pipe bands
  for(var i=0;i<segments.length;i++){
    var seg=segments[i];
    var aX=seg.start[0], aY=(plane==='XY'? seg.start[1]:seg.start[2]);
    var bX=seg.end[0],   bY=(plane==='XY'? seg.end[1]  :seg.end[2] );
    ctx.strokeStyle=COLORS.pipeBand; ctx.lineWidth=thickness; ctx.beginPath(); ctx.moveTo(mapX(aX),mapY(aY)); ctx.lineTo(mapX(bX),mapY(bY)); ctx.stroke();
  }
  // Centerlines
  for(var j=0;j<segments.length;j++){
    var sg=segments[j];
    var aX2=sg.start[0], aY2=(plane==='XY'? sg.start[1]:sg.start[2]);
    var bX2=sg.end[0],   bY2=(plane==='XY'? sg.end[1]  :sg.end[2] );
    var clr = COLORS[sg.drawCode]||COLORS.centerline;
    ctx.strokeStyle=clr; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(mapX(aX2),mapY(aY2)); ctx.lineTo(mapX(bX2),mapY(bY2)); ctx.stroke();
  }

  // Item index labels
  ctx.fillStyle='#000'; ctx.font='14px system-ui';
  for(var m=0;m<marks.length;m++){
    var mk=marks[m];
    var x=mk[1], y=(plane==='XY'? mk[2] : mk[3]);
    ctx.fillText(String(mk[0]), mapX(x)+4, mapY(y)-16);
  }

  // --- TOP PILLS + PICK MARKERS (restores your missing labels) ---
  var byAxis={}; picksets.forEach(function(ps){byAxis[ps.axis]=ps;});
  var topY=rect.y+10;
  function drawTopPill(x,y,w,h,color,label){
    ctx.fillStyle=color; var r=h/2;
    ctx.beginPath(); ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y);
    ctx.arc(x+w-r,y+r,r,-Math.PI/2,Math.PI/2); ctx.lineTo(x+r,y+h);
    ctx.arc(x+r,y+r,r,Math.PI/2,Math.PI*1.5); ctx.closePath(); ctx.fill();
    ctx.fillStyle='#000'; ctx.font='12px system-ui'; ctx.fillText(label,x+8,y+3);
  }
  function drawLeader(x1,y1,x2,y2,color){ ctx.strokeStyle=color; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); }
  function drawPickMarker(x,y,color,label){
    ctx.strokeStyle=color; ctx.fillStyle=color;
    ctx.beginPath(); ctx.moveTo(x,y-16); ctx.lineTo(x,y-2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x,y-2); ctx.lineTo(x-6,y-10); ctx.moveTo(x,y-2); ctx.lineTo(x+6,y-10); ctx.stroke();
    ctx.beginPath(); ctx.arc(x,y,4,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#000'; ctx.font='12px system-ui'; ctx.fillText(label,x+6,y-18);
  }
  var dimsL=[rect.x+12,160], dimsR=[rect.x+184,160];
  drawTopPill(dimsL[0],topY-8,dimsL[1],22,COLORS.pickLeft,'Left choker');
  drawTopPill(dimsR[0],topY-8,dimsR[1],22,COLORS.pickRight,'Right choker');

  if(plane==='XY'){
    if(byAxis.X){ var p=byAxis.X;
      drawLeader(dimsL[0]+dimsL[1]/2,topY+10,mapX(p.picks[0]),mapY(0),COLORS.pickLeft);
      drawPickMarker(mapX(p.picks[0]),mapY(0),COLORS.pickLeft,'L');
      drawLeader(dimsR[0]+dimsR[1]/2,topY+10,mapX(p.picks[1]),mapY(0),COLORS.pickRight);
      drawPickMarker(mapX(p.picks[1]),mapY(0),COLORS.pickRight,'R');
    }
    if(byAxis.Y){ var p2=byAxis.Y;
      drawLeader(dimsL[0]+dimsL[1]/2,topY+10,mapX(0),mapY(p2.picks[0]),COLORS.pickLeft);
      drawPickMarker(mapX(0),mapY(p2.picks[0]),COLORS.pickLeft,'L');
      drawLeader(dimsR[0]+dimsR[1]/2,topY+10,mapX(0),mapY(p2.picks[1]),COLORS.pickRight);
      drawPickMarker(mapX(0),mapY(p2.picks[1]),COLORS.pickRight,'R');
    }
  }else{
    if(byAxis.X){ var pxs=byAxis.X;
      drawLeader(dimsL[0]+dimsL[1]/2,topY+10,mapX(pxs.picks[0]),mapY(0),COLORS.pickLeft);
      drawPickMarker(mapX(pxs.picks[0]),mapY(0),COLORS.pickLeft,'L');
      drawLeader(dimsR[0]+dimsR[1]/2,topY+10,mapX(pxs.picks[1]),mapY(0),COLORS.pickRight);
      drawPickMarker(mapX(pxs.picks[1]),mapY(0),COLORS.pickRight,'R');
    }
    if(byAxis.Z){ var pz=byAxis.Z;
      drawLeader(dimsL[0]+dimsL[1]/2,topY+10,mapX(0),mapY(pz.picks[0]),COLORS.pickLeft);
      drawPickMarker(mapX(0),mapY(pz.picks[0]),COLORS.pickLeft,'L');
      drawLeader(dimsR[0]+dimsR[1]/2,topY+10,mapX(0),mapY(pz.picks[1]),COLORS.pickRight);
      drawPickMarker(mapX(0),mapY(pz.picks[1]),COLORS.pickRight,'R');
    }
  }

  // --- TRUE LEG LINES (bight → picks, visual) ---
  function projXY(p){ return [p[0], p[1]]; }
  function projXZ(p){ return [p[0], p[2]]; }
  var proj = (plane==='XY')?projXY:projXZ;

  function axisPick(axis,val){ return (axis==='X')?[val,0,0]:(axis==='Y')?[0,val,0]:[0,0,val]; }

  var primary = picksets[0].axis; var secondary = picksets[1] ? picksets[1].axis : primary;

  // Place a bight on the active pick plane (CG projection logic lives in compute; here we draw a representative point)
  var B=[0,0,0]; // visual placeholder
  var Buv = proj(B);

  var L_A = axisPick(primary,  byAxis[primary].picks[0]);
  var L_B = axisPick(secondary, byAxis[secondary].picks[0]);
  var R_A = axisPick(primary,  byAxis[primary].picks[1]);
  var R_B = axisPick(secondary, byAxis[secondary].picks[1]);

  var L_Auv = proj(L_A), L_Buv = proj(L_B), R_Auv = proj(R_A), R_Buv = proj(R_B);

  function drawLeg(u1,v1,u2,v2,color,label){
    ctx.strokeStyle=color; ctx.lineWidth=2.5;
    ctx.beginPath(); ctx.moveTo(mapX(u1),mapY(v1)); ctx.lineTo(mapX(u2),mapY(v2)); ctx.stroke();
    var mx=(u1+u2)/2, my=(v1+v2)/2;
    ctx.fillStyle='#000'; ctx.font='12px system-ui';
    ctx.fillText(label, mapX(mx)+6, mapY(my)-14);
  }
  drawLeg(Buv[0],Buv[1], L_Auv[0],L_Auv[1], COLORS.pickLeft,  primary+'-leg');
  drawLeg(Buv[0],Buv[1], L_Buv[0],L_Buv[1], COLORS.pickLeft,  secondary+'-leg');
  drawLeg(Buv[0],Buv[1], R_Auv[0],R_Auv[1], COLORS.pickRight, primary+'-leg');
  drawLeg(Buv[0],Buv[1], R_Buv[0],R_Buv[1], COLORS.pickRight, secondary+'-leg');

  // --- COUPLING CENTER ARROWS (bi-directional, green) ---
  if(togglePrevCouplingEl.checked){
    var cx = Number(cXEl && cXEl.value || 0),
        cy = Number(cYEl && cYEl.value || 0),
        cz = Number(cZEl && cZEl.value || 0);
    var Cuv = (plane==='XY')?[cx,cy]:[cx,cz];

    function drawArrow(u1,v1,u2,v2,text){
      var x1=mapX(u1), y1=mapY(v1), x2=mapX(u2), y2=mapY(v2);
      ctx.strokeStyle='#00e676'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      function head(xa,ya,xb,yb){ var ang=Math.atan2(yb-ya, xb-xa), sz=8;
        ctx.beginPath();
        ctx.moveTo(xb, yb);
        ctx.lineTo(xb - sz*Math.cos(ang - Math.PI/6), yb - sz*Math.sin(ang - Math.PI/6));
        ctx.moveTo(xb, yb);
        ctx.lineTo(xb - sz*Math.cos(ang + Math.PI/6), yb - sz*Math.sin(ang + Math.PI/6));
        ctx.stroke();
      }
      head(x1,y1,x2,y2); head(x2,y2,x1,y1);
      ctx.fillStyle='#00e676'; ctx.font='12px system-ui';
      ctx.fillText(text, (x1+x2)/2 + 6, (y1+y2)/2 - 10);
    }
    function delta(a,b){ return Math.abs(a-b).toFixed(1)+'"'; }

    // Primary axis arrows
    drawArrow(Cuv[0],Cuv[1], L_Auv[0],L_Auv[1], delta(Cuv[0],L_Auv[0]));
    drawArrow(Cuv[0],Cuv[1], R_Auv[0],R_Auv[1], delta(Cuv[0],R_Auv[0]));
    // Secondary axis arrows
    drawArrow(Cuv[0],Cuv[1], L_Buv[0],L_Buv[1], delta(Cuv[1],L_Buv[1]));
    drawArrow(Cuv[0],Cuv[1], R_Buv[0],R_Buv[1], delta(Cuv[1],R_Buv[1]));
  }

  // Frame
  ctx.strokeStyle='#cfd4d9'; ctx.lineWidth=1; ctx.strokeRect(rect.x,rect.y,rect.w,rect.h);
}
  /* Wire UI */
  function wireOnce(){
    var addBtn = el('addBtn'); if(addBtn && !addBtn.dataset.bound){ addBtn.dataset.bound='1'; addBtn.addEventListener('click', addItem); }
    var clearBtn = el('clearBtn'); if(clearBtn && !clearBtn.dataset.bound){ clearBtn.dataset.bound='1'; clearBtn.addEventListener('click', resetAll); }
    var removeBtn = el('removeLastBtn'); if(removeBtn && !removeBtn.dataset.bound){ removeBtn.dataset.bound='1'; removeBtn.addEventListener('click', removeLast); }
    var computeBtn = el('computeBtn'); if(computeBtn && !computeBtn.dataset.bound){ computeBtn.dataset.bound='1'; computeBtn.addEventListener('click', computeAndDraw); }
    var downloadBtn = el('downloadBtn'); if(downloadBtn && !downloadBtn.dataset.bound){
      downloadBtn.dataset.bound='1';
      downloadBtn.addEventListener('click', function(){
        var a=document.createElement('a'); var ts=new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
        a.download=ts+'_rigging.png'; a.href=el('sheet').toDataURL('image/png'); a.click();
      });
    }
    if (pickModeEl && pickAxesEl) {
  function syncPickAxesForMode(){
    var is2 = (pickModeEl.value === '2');
    // Disable Z pairs when in 2-pick mode
    for (var i=0;i<pickAxesEl.options.length;i++){
      var v = pickAxesEl.options[i].value;
      var hasZ = (v.indexOf('Z') !== -1);
      pickAxesEl.options[i].disabled = is2 && hasZ;
    }
    // If current selection is disallowed, snap to XY
    if (is2 && (pickAxesEl.value === 'XZ' || pickAxesEl.value === 'YZ')) {
      pickAxesEl.value = 'XY';
    }
  }
  pickModeEl.addEventListener('change', syncPickAxesForMode);
  syncPickAxesForMode();
}
    itemTypeEl.addEventListener('change', updateDetailRows);
  }

  window.addEventListener('load', function(){
pickModeEl=el('pickMode');
pickAxesEl=el('pickAxes');
togglePrevCouplingEl=el('togglePrevCoupling');
  itemTypeEl=el('itemType'); orientEl=el('orient'); lenRow=el('lenRow'); wpiEl=el('wpi'); wpiLabel=el('wpiLabel'); lenInEl=el('lenIn');
  fixedRow=el('fixedRow'); fixedWEl=el('fixedW'); fixedLEl=el('fixedL');
  single90Row=el('single90Row');
  itemsDiv=el('items'); summaryDiv=el('summary'); sheet=el('sheet'); debugDiv=el('debug');
  // NEW:
  cXEl=el('cX'); cYEl=el('cY'); cZEl=el('cZ');
  laymanDiv=el('layman');

  setupCanvas(sheet); updateDetailRows(); wireOnce();
  debugDiv.textContent='debug: ready (v11.01 features: coupling center + layman + true legs + arrows)';
});
}
</script>
</body>
</html>
