<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Simple COG Rigging Calculator — Single Pick + True Elbows</title>
<style>
  :root{
    --bg:#ffffff; --ink:#111; --panel:#f6f8fa; --border:#e9ecef; --accent:#0d6efd;
    --pick:#ffd60a; --roll:#5bc0ff;
  }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:16px; color:var(--ink); background:var(--bg); }
  h1 { font-size:20px; margin:0 0 10px; display:flex; align-items:center; gap:10px;}
  .badge{display:inline-block; padding:2px 8px; border-radius:999px; background:#d1e7dd; color:#0f5132; font-weight:700; font-size:12px;}
  fieldset { border:1px solid #ccc; border-radius:10px; margin:10px 0; padding:10px 12px; }
  legend { padding:0 6px; font-weight:600; }
  label { display:block; margin:6px 0 2px; font-size:14px; }
  select, input[type="number"] { width:100%; font-size:16px; padding:10px 12px; box-sizing:border-box; border-radius:8px; border:1px solid #cfd4d9; }
  .row { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
  .row3 { display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px; }
  .btn { display:inline-block; padding:10px 12px; margin:8px 6px 0 0; border-radius:10px; background:var(--accent); color:#fff; border:none; font-size:16px; cursor:pointer;}
  .btn.secondary{ background:#6c757d; }
  .items{ margin-top:6px;}
  .item{ padding:8px; border:1px dashed #999; border-radius:8px; margin-bottom:8px; font-size:14px;}
  .out{ background:var(--panel); padding:12px; border-radius:10px; border:1px solid var(--border); line-height:1.5; font-size:15px;}
  .out h3{ margin:6px 0; font-size:16px;}
  .pill{ display:inline-block; padding:2px 8px; border-radius:999px; font-weight:600; font-size:12px; color:#000; background:var(--pick);}
  .muted{ color:#555; font-size:12px; }
  #sheet{ width:100%; max-width:1000px; background:#fff; border:1px solid #ddd; border-radius:8px; display:block;}
  #debug{ margin-top:6px; font-size:12px; color:#b00020; white-space:pre-wrap; border:1px dashed #ddd; padding:6px; border-radius:6px;}
  .bigcall { font-size:18px; font-weight:800; padding:8px 10px; border-radius:10px; background:#fff3cd; border:1px solid #ffe69c; display:inline-block; }
</style>
</head>
<body>
<h1>Rigging CG Helper — Single Pick <span class="badge" id="badge">Ready</span></h1>

<!-- OUTPUT -->
<fieldset>
  <legend>Output (quick)</legend>
  <div id="summary" class="out">Add items and click “Compute + Draw”.</div>
  <div class="muted">Legend: <span class="pill">Pick</span> · “Left Edge” = minimum coordinate on the chosen axis, and distance is measured along the <b>centerline path</b> (follows arcs on elbows).</div>
</fieldset>

<!-- PICK SETUP -->
<fieldset>
  <legend>Pick setup (single pick)</legend>
  <div class="row">
    <label>Pick axis
      <select id="axisPick">
        <option value="AUTO" selected>Auto (largest span)</option>
        <option value="X">X — Left → Right</option>
        <option value="Y">Y — Toward / Away</option>
        <option value="Z">Z — Up / Down</option>
      </select>
    </label>
    <label>Pipe OD (for roll info; in)
      <input id="pipeOD" type="number" inputmode="decimal" value="24">
    </label>
  </div>
</fieldset>

<!-- ROLL HELPER -->
<fieldset>
  <legend>Roll helper (operator-proof)</legend>
  <div class="row">
    <label>Target roll to set on the pipe (degrees)
      <input id="targetRoll" type="number" inputmode="decimal" value="0">
      <div class="muted">Positive = roll the pipe toward +Y (toward you). Negative = roll toward −Y (away).</div>
    </label>
    <div>
      <button id="btnPlumb45" class="btn secondary" type="button">Set +45° for “plumb a 45° face”</button>
      <div class="muted">Convenience preset.</div>
    </div>
  </div>
  <div class="muted">“CG roll” below is informational (from CG offset on a round). “Target roll” is what you tell the operator.</div>
</fieldset>

<!-- ADD ITEMS -->
<fieldset>
  <legend>Add item</legend>
  <div class="row">
    <label>Item type
      <select id="itemType">
        <option value="P">24″ pipe (per-inch)</option>
        <option value="V">24″ valve (regular)</option>
        <option value="C">24″ coupling (weight only)</option>
        <option value="E">24″ 90° elbow (true arc)</option>
        <option value="F">24″ 45° elbow (true arc)</option>
        <option value="T">24″ tee (plain)</option>
        <option value="W">24″ tee with valve</option>
        <option value="X">Custom per-inch</option>
        <option value="Y">Custom fixed</option>
      </select>
    </label>
    <label>Orientation (axis + layman direction)
      <select id="orient">
        <option value="A" selected>A — X+ (Left → Right)</option>
        <option value="B">B — X− (Right → Left)</option>
        <option value="C">C — Y+ (Toward)</option>
        <option value="D">D — Y− (Away)</option>
        <option value="E">E — Z+ (Up)</option>
        <option value="F">F — Z− (Down)</option>
      </select>
    </label>
  </div>
  <div class="row" id="lenRow">
    <label>Length (in) — lines & per-inch items
      <input id="lenIn" type="number" inputmode="decimal" value="60">
    </label>
    <label id="wpiLabel">Weight per inch (lb/in)
      <input id="wpi" type="number" inputmode="decimal" value="8.2">
    </label>
  </div>
  <div class="row" id="fixedRow" style="display:none">
    <label>Total weight (lb)
      <input id="fixedW" type="number" inputmode="decimal" value="0">
    </label>
    <label>Effective length along chosen axis (in)
      <input id="fixedL" type="number" inputmode="decimal" value="0">
    </label>
  </div>

  <button class="btn" id="addBtn" type="button">Add item</button>
  <button class="btn secondary" id="clearBtn" type="button">Clear list</button>

  <div class="items" id="items"></div>
  <div id="debug">debug: ready</div>
</fieldset>

<button class="btn" id="computeBtn" type="button">Compute + Draw</button>
<button class="btn secondary" id="downloadBtn" type="button" disabled>Download PNG</button>

<!-- DRAWINGS -->
<fieldset>
  <legend>Drawings</legend>
  <canvas id="sheet"></canvas>
  <div class="muted">Plan (X–Y) and Elevation (X–Z). Elbows render as true arcs. The single pick is placed on the chosen axis at the CG projection; distance is along the centerline path.</div>
</fieldset>

<script>
/* ---------- setup ---------- */
(function(){ const b=document.getElementById('badge'); if(b) b.textContent='Ready'; })();
function el(id){ return document.getElementById(id); }
function setupCanvas(canvas, cssW, cssH){
  cssW=cssW||1000; cssH=cssH||1000;
  const dpr=window.devicePixelRatio||1;
  canvas.style.width=cssW+'px'; canvas.style.height=cssH+'px';
  canvas.width=Math.floor(cssW*dpr); canvas.height=Math.floor(cssH*dpr);
  const ctx=canvas.getContext('2d'); ctx.setTransform(dpr,0,0,dpr,0,0); ctx.textBaseline='top'; return ctx;
}
const sheet=el('sheet'); let ctx=setupCanvas(sheet);

/* ---------- constants ---------- */
const W_PER_IN_DEFAULT=8.2;
/* Previous elbow numbers were linear “spans”; we’ll treat them as arc lengths. */
const ARC_L_90=36.0, ARC_L_45=15.0;
const W_EL90=475.0, W_EL45=240.0;
const W_COUP=115.0;
const W_VALVE_BODY=451.0, L_VALVE_STD=12.0;
const W_TEE_BODY=477.0, L_TEE=20.0;

const COLORS={
  axisX:'#d12222', axisY:'#2a9d2a', axisZ:'#1f6feb',
  line:'#000', pipeBand:'rgba(100,100,100,0.18)',
  P:'#666666', E:'#2aa198', F:'#2aa198', V:'#ff9100', C:'#8e44ad', T:'#d33682', W:'#d33682', X:'#8d6e63', Y:'#8d6e63',
  pick:getComputedStyle(document.documentElement).getPropertyValue('--pick')||'#ffd60a',
  roll:getComputedStyle(document.documentElement).getPropertyValue('--roll')||'#5bc0ff'
};
const ORIENTS={ A:[ 1,0,0], B:[-1,0,0], C:[ 0,1,0], D:[ 0,-1,0], E:[ 0,0,1], F:[ 0,0,-1] };

/* ---------- helpers ---------- */
function clone(v){ return [v[0],v[1],v[2]]; }
function add(a,b){ return [a[0]+b[0],a[1]+b[1],a[2]+b[2]]; }
function sub(a,b){ return [a[0]-b[0],a[1]-b[1],a[2]-b[2]]; }
function mul(a,k){ return [a[0]*k,a[1]*k,a[2]*k]; }
function dot(a,b){ return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }
function norm(a){ const m=Math.hypot(a[0],a[1],a[2])||1; return [a[0]/m,a[1]/m,a[2]/m]; }
function cross(a,b){ return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
function r4(x){ return Math.round(x*4)/4; }
function r8(x){ return Math.round(x*8)/8; }
function fmtFtIn(x){
  const v=r4(x), ft=Math.floor(v/12), rem=v-ft*12;
  const whole=Math.floor(rem), frac=Math.round((rem-whole)*100)/100;
  const map={"0":"", "0.25":"-1/4", "0.5":"-1/2", "0.75":"-3/4"};
  const tag=(map.hasOwnProperty(String(frac))?map[String(frac)]:null);
  const inch=(tag!==null)? (whole+tag+'"') : (rem.toFixed(2)+'"');
  return ft? (ft+"' "+inch) : inch;
}

/* ---------- state ---------- */
let items=[], pieces=[], marks=[];

/* Piece schema:
  { type:'line', tCode, start:[x,y,z], end:[x,y,z], dir:[dx,dy,dz], L, w }
  { type:'arc',  tCode, start:[x,y,z], end:[x,y,z], center:[x,y,z], n:[nx,ny,nz],
                 r, theta (signed, rad), a0 (start angle), L, w }
  marks[i] = centerline label positions for item i (for drawing IDs)
*/

/* ---------- UI wiring ---------- */
window.addEventListener('load', ()=>{
  el('itemType').addEventListener('change', updateDetailRows);
  el('addBtn').addEventListener('click', addItem);
  el('clearBtn').addEventListener('click', resetAll);
  el('computeBtn').addEventListener('click', computeAndDraw);
  el('downloadBtn').addEventListener('click', ()=>{
    const a=document.createElement('a'); const ts=new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
    a.download=ts+'_rigging.png'; a.href=sheet.toDataURL('image/png'); a.click();
  });
  el('btnPlumb45').addEventListener('click', ()=>{ el('targetRoll').value=45; });
  updateDetailRows();
});
function updateDetailRows(){
  const t=el('itemType').value;
  el('lenRow').style.display = (t==='P'||t==='X')?'grid':'none';
  el('wpiLabel').style.display = (t==='P'||t==='X')?'block':'none';
  el('fixedRow').style.display = (t==='Y')?'grid':'none';
}

/* ---------- build geometry ---------- */
function getEnd(){ return pieces.length===0?[0,0,0]:clone(pieces[pieces.length-1].end); }
function getPrevDir(){ // default X+ if none
  if(pieces.length===0) return [1,0,0];
  const last=pieces[pieces.length-1];
  if(last.type==='line') return norm(sub(last.end,last.start));
  // tangent at end of arc:
  const tDir = cross(last.n, sub(last.end,last.center));
  return norm(tDir); // direction from end going forward (consistent enough for “incoming” to next)
}
function addItemRow(idx, txt){
  const d=document.createElement('div'); d.className='item'; d.textContent=(idx+'. '+txt); el('items').appendChild(d);
}

function pushLine(tCode, dir, L, w, labelIdx){
  L=Math.max(0, Number(L)||0); dir=norm(dir);
  const s=getEnd(), e=add(s, mul(dir, L));
  const pc={type:'line', tCode, start:s, end:e, dir:dir, L:L, w:w};
  pieces.push(pc);
  const mid=add(s, mul(dir, L/2));
  marks.push([labelIdx, mid[0], mid[1], mid[2]]);
}
function pushArc(tCode, prevDir, nextDir, arcLen, thetaAbsDeg, w, labelIdx){
  // Build a circular arc from current end, turning from prevDir toward nextDir by thetaAbsDeg (use sign from orientation).
  const s=getEnd();
  const u=norm(prevDir);
  let v=norm(nextDir);
  // Ensure v is perpendicular to u (project out any u component)
  v=norm(sub(v, mul(u, dot(u,v))));
  // Determine signed theta: choose sign that rotates u toward v with normal n = u x v
  const thetaAbs = thetaAbsDeg*Math.PI/180;
  const n = norm(cross(u,v));
  if(Math.hypot(n[0],n[1],n[2])<1e-8){ // degenerate (same or opposite): default rotate in XY plane around +Z
    v = norm(cross([0,0,1], u)); // fallback
  }
  const theta = (thetaAbsDeg>=0? +thetaAbs : -thetaAbs); // positive for right-hand about n

  // Radius from arc length: L = R * |theta|
  const R = (Math.abs(theta)>1e-6)? (arcLen/Math.abs(theta)) : 1e6; // large if tiny angle

  // Geometry: start tangent = u; center lies R to the "left" of u in plane defined by n
  // Local frame at start: u (tangent), w = n×u (points to center from start)
  const wv = norm(cross(n,u));
  const c = add(s, mul(wv, R)); // center
  const a0 = Math.atan2(s[1]-c[1], s[0]-c[0]); // angle of start radius in XY for drawing per-projection (we'll recompute per plane)
  // End point by rotating start radius by theta around n:
  function rotateAroundN(p){
    // Rodrigues’ formula around n by angle theta: rotate vector r = (p - c)
    const r = sub(p,c), k=n, ct=Math.cos(theta), st=Math.sin(theta);
    const rRot = add( add( mul(r,ct), mul(cross(k,r),st) ), mul(k, dot(k,r)*(1-ct)) );
    return add(c, rRot);
  }
  const e = rotateAroundN(s);

  const pc={type:'arc', tCode, start:s, end:e, center:c, n:n, r:R, theta: (theta>=0? +theta : -thetaAbs), a0:a0, L:arcLen, w:w};
  pieces.push(pc);

  // centroid of circular arc (uniform density) lies at distance r * sin(θ/2)/(θ/2) from center along the bisector
  const th=pc.theta, r=pc.r;
  const k=(Math.abs(th)>1e-8)? (r*Math.sin(th/2)/(th/2)) : r;
  // unit vector from center to mid-angle:
  // For 3D, use rotation by th/2 from start radius:
  function rotateBy(alpha, p){
    const r = sub(p,pc.center), k=pc.n, ct=Math.cos(alpha), st=Math.sin(alpha);
    const rRot = add( add( mul(r,ct), mul(cross(k,r),st) ), mul(k, dot(k,r)*(1-ct)) );
    return add(pc.center, rRot);
  }
  const midRadPoint = rotateBy(th/2, s);
  const radial = norm(sub(midRadPoint, pc.center));
  const centroid = add(pc.center, mul(radial, k));
  marks.push([labelIdx, centroid[0], centroid[1], centroid[2]]);
}

/* ---------- add items (with true arcs for elbows) ---------- */
function addItem(){
  try{
    const t=el('itemType').value, idx=items.length+1, dirSel=ORIENTS[el('orient').value]||[1,0,0];

    function addLinear(name, L, W, tCode){
      items.push({name, length:L, weight:W, tCode});
      pushLine(tCode, dirSel, L, W, idx);
      addItemRow(idx, `${name} L=${L.toFixed(1)} in, W=${W.toFixed(1)} lb`);
    }

    if(t==='P'){
      const L=Number(el('lenIn').value)||0, wpi=Number(el('wpi').value)||W_PER_IN_DEFAULT;
      const W=wpi*L; items.push({name:'24" pipe', length:L, weight:W, tCode:'P'});
      pushLine('P', dirSel, L, W, idx);
      addItemRow(idx, `Pipe ${L.toFixed(1)} in @ ${wpi} → ${W.toFixed(1)} lb`);

    }else if(t==='X'){
      const L=Number(el('lenIn').value)||0, wpi=Number(el('wpi').value)||W_PER_IN_DEFAULT;
      const W=wpi*L; items.push({name:'Custom per-inch', length:L, weight:W, tCode:'X'});
      pushLine('X', dirSel, L, W, idx);
      addItemRow(idx, `Custom per-inch ${L.toFixed(1)} in @ ${wpi} → ${W.toFixed(1)} lb`);

    }else if(t==='Y'){
      const WY=Number(el('fixedW').value)||0, LY=Number(el('fixedL').value)||0;
      items.push({name:'Custom fixed', length:LY, weight:WY, tCode:'Y'});
      pushLine('Y', dirSel, LY, WY, idx);
      addItemRow(idx, `Custom fixed ${WY.toFixed(1)} lb, eff L=${LY.toFixed(1)} in`);

    }else if(t==='V'){
      items.push({name:'Valve (regular)', length:L_VALVE_STD, weight:W_VALVE_BODY, tCode:'V'});
      pushLine('V', dirSel, L_VALVE_STD, W_VALVE_BODY, idx);
      addItemRow(idx, `Valve reg L=${L_VALVE_STD} in, W=${W_VALVE_BODY.toFixed(1)} lb`);

    }else if(t==='C'){
      // coupling: weight at joint, no length contribution (draw tiny stub)
      items.push({name:'Coupling', length:0, weight:W_COUP, tCode:'C'});
      pushLine('C', dirSel, 1, W_COUP, idx); // 1" visual stub
      addItemRow(idx, `Coupling W=${W_COUP.toFixed(1)} lb`);

    }else if(t==='T'){
      items.push({name:'Tee (plain)', length:L_TEE, weight:W_TEE_BODY, tCode:'T'});
      pushLine('T', dirSel, L_TEE, W_TEE_BODY, idx);
      addItemRow(idx, `Tee L=${L_TEE} in, W=${W_TEE_BODY.toFixed(1)} lb`);

    }else if(t==='W'){
      const WT=W_TEE_BODY+W_VALVE_BODY;
      items.push({name:'Tee + valve', length:L_TEE, weight:WT, tCode:'W'});
      pushLine('W', dirSel, L_TEE, WT, idx);
      addItemRow(idx, `Tee + valve L=${L_TEE} in, W=${WT.toFixed(1)} lb`);

    }else if(t==='E' || t==='F'){
      const prevDir = getPrevDir();
      const nextDir = dirSel;
      const arcLen = (t==='E')? ARC_L_90 : ARC_L_45;
      const thetaDeg = (t==='E')? 90 : 45;
      const w = (t==='E')? W_EL90 : W_EL45;
      items.push({name:(t==='E'?'90° elbow':'45° elbow'), length:arcLen, weight:w, tCode:t});
      pushArc(t, prevDir, nextDir, arcLen, thetaDeg, w, idx);
      addItemRow(idx, `${t==='E'?'90° elbow':'45° elbow'} arcLen=${arcLen} in, W=${w.toFixed(1)} lb`);
    }

    el('debug').textContent='debug: items='+items.length+', pieces='+pieces.length;
  }catch(e){
    el('debug').textContent='debug: addItem error: '+e;
  }
}

function resetAll(){
  items=[]; pieces=[]; marks=[];
  el('items').innerHTML='';
  el('summary').innerHTML='Add items and click “Compute + Draw”.';
  ctx.clearRect(0,0,sheet.width,sheet.height);
  el('debug').textContent='debug: reset';
}

/* ---------- CG (with auto couplings at joints) ---------- */
function computeCG(){
  let totalW=0, sum=[0,0,0];
  // item centroids already in marks (aligned with items order)
  for(let i=0;i<items.length;i++){
    const w=items[i].weight, p=[marks[i][1],marks[i][2],marks[i][3]];
    totalW+=w; sum=add(sum, mul(p,w));
  }
  // auto coupling at every joint (except before first)
  for(let j=0;j<pieces.length-1;j++){
    const end=pieces[j].end; totalW+=W_COUP; sum=add(sum, mul(end, W_COUP));
  }
  return {CG: totalW? mul(sum,1/totalW):[0,0,0], totalW};
}

/* ---------- axis & extents ---------- */
function extentAlongAxis(axisIndex){
  // use all vertices (piece ends and starts)
  const xs=[];
  for(const pc of pieces){ xs.push(pc.start[axisIndex], pc.end[axisIndex]); }
  const mn=Math.min.apply(null, xs), mx=Math.max.apply(null, xs);
  return {min:mn, max:mx, span:mx-mn};
}
function chooseAxisPick(sel){
  if(sel!=='AUTO') return sel;
  const exX=extentAlongAxis(0), exY=extentAlongAxis(1), exZ=extentAlongAxis(2);
  let best='X', span=exX.span;
  if(exY.span>span){ best='Y'; span=exY.span; }
  if(exZ.span>span){ best='Z'; span=exZ.span; }
  return best;
}

/* ---------- path mapping & “distance from left edge” ---------- */
/* We need path-length s (centerline) ↔ 3D point mapping to:
   1) place pick on chosen axis at x_pick = CG[axis]
   2) report distance from min(axis) “Left Edge” along centerline path.
*/
function buildCumulativeLengths(){
  const cum=[0]; let acc=0;
  for(const pc of pieces){ acc+=pc.L; cum.push(acc); }
  return cum; // length = cum[i+1]-cum[i] for pieces[i]
}
function pointAtPiece(pc, sLocal){ // 0..pc.L
  if(pc.type==='line'){
    const t=(pc.L? sLocal/pc.L : 0);
    return add(pc.start, mul(sub(pc.end,pc.start), t));
  }else{
    const alpha = (pc.theta>=0? +1 : -1) * (Math.abs(sLocal)/pc.r); // signed angle
    // rotate start radius by alpha around n
    const p0=pc.start, c=pc.center, n=pc.n;
    const r0=sub(p0,c), ct=Math.cos(alpha), st=Math.sin(alpha);
    const rRot = add( add( mul(r0,ct), mul(cross(n,r0),st) ), mul(n, dot(n,r0)*(1-ct)) );
    return add(c, rRot);
  }
}
function axisIndexFromLetter(ax){ return (ax==='X'?0:(ax==='Y'?1:2)); }

/* Find path position s* whose point has axis coordinate closest to targetAxisVal.
   We line-search over pieces with small steps; fast & robust for field use. */
function findSForAxisVal(axisIdx, targetVal){
  const cum=buildCumulativeLengths();
  const step=0.25; // 1/4" resolution along path
  let bestS=0, bestErr=Infinity;
  let S=0;
  for(let i=0;i<pieces.length;i++){
    const pc=pieces[i];
    const nSteps=Math.max(1, Math.ceil(pc.L/step));
    for(let k=0;k<=nSteps;k++){
      const sLocal=Math.min(pc.L, k*pc.L/nSteps);
      const p=pointAtPiece(pc, sLocal);
      const err=Math.abs(p[axisIdx]-targetVal);
      if(err<bestErr){ bestErr=err; bestS=S+sLocal; }
    }
    S+=pc.L;
  }
  return bestS; // centerline distance from start (left edge origin)
}

/* ---------- compute & draw ---------- */
function computeAndDraw(){
  if(items.length===0){ alert('Add at least one item.'); return; }

  const {CG,totalW}=computeCG();
  const axisPick = chooseAxisPick(el('axisPick').value);
  const ax = axisIndexFromLetter(axisPick);
  const ex = extentAlongAxis(ax);

  // Pick location: project CG onto chosen axis → find nearest point on the centerline path with that axis value.
  const sPick = findSForAxisVal(ax, CG[ax]);
  const cum=buildCumulativeLengths();
  const pickPoint = (function(){
    // convert sPick to piece index + local s
    let S=0; for(let i=0;i<pieces.length;i++){ if(sPick<=S+pieces[i].L){ return pointAtPiece(pieces[i], sPick-S); } S+=pieces[i].L; }
    return clone(pieces.length? pieces[pieces.length-1].end : [0,0,0]);
  })();

  // Distance “from Left Edge” along centerline path:
  // “Left Edge” is min coordinate on that axis; find start index where that min occurs along the path, then measure arc-length to pick.
  let sLeftEdge=0; {
    let bestVal=Infinity, bestS=0, S=0;
    for(const pc of pieces){
      // check start & end; (fine enough—min will be at a vertex for piecewise-monotone axes)
      const cand=[pc.start, pc.end];
      for(const p of cand){
        if(p[ax]<bestVal){ bestVal=p[ax]; bestS=S + (p===pc.end? pc.L : 0); }
      }
      S+=pc.L;
    }
    sLeftEdge=bestS;
  }
  const distAlongPath = Math.abs(sPick - sLeftEdge);

  // CG-based informational roll
  const R=(Number(el('pipeOD').value)||24)/2;
  const y=CG[1], yclamped=Math.max(-R, Math.min(R, y));
  const rollDegInfo = (R>0)? (Math.asin(yclamped/R)*180/Math.PI) : 0;
  const rollSideInfo = (y>0?'toward +Y':(y<0?'toward -Y':'no roll needed'));
  const arc = R * (Math.abs(rollDegInfo)*Math.PI/180);

  // Operator target roll
  let targetRoll = parseFloat(el('targetRoll').value);
  if(!(targetRoll===0 || !!targetRoll)) targetRoll = 0;

  // Output
  let html='';
  html += '<h3>Totals</h3>';
  html += '<div>Total weight: <b>'+totalW.toFixed(1)+' lb</b></div>';
  html += '<div>CG (in): X=<b>'+CG[0].toFixed(2)+'</b>, Y=<b>'+CG[1].toFixed(2)+'</b>, Z=<b>'+CG[2].toFixed(2)+'</b></div>';
  html += '<h3>Pick</h3>';
  html += '<div><span class="pill">Pick</span> axis <b>'+axisPick+'</b> · from Left Edge (path): <b>'+fmtFtIn(distAlongPath)+'</b></div>';
  html += '<div class="muted">If the pick falls on an elbow, this distance is the <i>arc length</i> along the elbow’s centerline, not a straight chord.</div>';
  html += '<h3>Roll</h3>';
  html += '<div><span style="background:'+COLORS.roll+';padding:2px 6px;border-radius:999px;font-weight:700;font-size:12px;color:#000;">CG roll (info)</span> ≈ '+rollDegInfo.toFixed(1)+'° '+rollSideInfo+'; circumference offset per choker ≈ '+(r8(arc)).toFixed(3).replace(/\\.000$/,'')+'"</div>';
  html += '<div style="margin-top:8px;"><span class="bigcall">SET PIPE ROLL: '+(targetRoll>=0?'+':'')+targetRoll.toFixed(1)+'° (toward '+(targetRoll>=0?'+Y':'−Y')+')</span></div>';
  el('summary').innerHTML = html;

  drawAll({axisPick, pickPoint, CG, sPick, sLeftEdge});
  el('downloadBtn').disabled=false;
}

/* ---------- drawing ---------- */
function drawAll(p){
  ctx=setupCanvas(sheet, 1000, 1050);
  const W=1000,H=1050,pad=28, secH=Math.floor((H-pad*4)/2);
  const planRect={x:pad,y:pad,w:W-2*pad,h:secH};
  const elevRect={x:pad,y:pad*2+secH,w:W-2*pad,h:secH};

  ctx.fillStyle='#fff'; ctx.fillRect(0,0,W,H);

  const verts=[[0,0,0]]; for(const pc of pieces){ verts.push(pc.end); }
  const px=verts.map(v=>v[0]), py=verts.map(v=>v[1]), pz=verts.map(v=>v[2]);

  drawProjection(planRect, px, py, 'Plan (X–Y)', p, 'XY');
  drawProjection(elevRect, px, pz, 'Elevation (X–Z)', p, 'XZ');

  // Roll dial
  drawRollDial(W/2, H-120, 90, parseFloat(el('targetRoll').value)||0);
}

function drawProjection(rect, px, py, title, p, plane){
  const minX=Math.min.apply(null, px.concat([0])), maxX=Math.max.apply(null, px.concat([1]));
  const minY=Math.min.apply(null, py.concat([-1])), maxY=Math.max.apply(null, py.concat([1]));

  const pad=46, sx=(rect.w-pad*2)/((maxX-minX)||1), sy=(rect.h-pad*2)/((maxY-minY)||1), s=Math.min(sx,sy);
  const mapX=x=>rect.x+pad+(x-minX)*s;
  const mapY=y=>rect.y+rect.h-pad-(y-minY)*s;

  ctx.fillStyle='#000'; ctx.font='18px system-ui'; ctx.fillText(title, rect.x, rect.y-6);

  // axes
  ctx.lineWidth=2;
  ctx.strokeStyle=COLORS.axisX; ctx.beginPath(); ctx.moveTo(mapX(minX), mapY(0)); ctx.lineTo(mapX(maxX), mapY(0)); ctx.stroke();
  ctx.strokeStyle=(plane==='XY')?COLORS.axisY:COLORS.axisZ;
  const x0=mapX(0); ctx.beginPath(); ctx.moveTo(x0, mapY(minY)); ctx.lineTo(x0, mapY(maxY)); ctx.stroke();

  // pipe band (thick, underlay)
  const thickness=Math.min(28, Math.max(8, s*24*0.6)); ctx.lineCap='round';
  for(const pc of pieces){
    if(pc.type==='line'){
      const x0=mapX(pc.start[0]), y0=mapY(plane==='XY'?pc.start[1]:pc.start[2]);
      const x1=mapX(pc.end[0]),   y1=mapY(plane==='XY'?pc.end[1]:pc.end[2]);
      ctx.strokeStyle=COLORS.pipeBand; ctx.lineWidth=thickness; ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
    }else{
      // project arc into plane (use only those plane coords)
      const sPt=[pc.start[0], plane==='XY'?pc.start[1]:pc.start[2]];
      const ePt=[pc.end[0],   plane==='XY'?pc.end[1]:pc.end[2]];
      const cPt=[pc.center[0],plane==='XY'?pc.center[1]:pc.center[2]];
      // angles in projection:
      const a0=Math.atan2(sPt[1]-cPt[1], sPt[0]-cPt[0]);
      const a1=a0 + pc.theta; // signed
      ctx.strokeStyle=COLORS.pipeBand; ctx.lineWidth=thickness; ctx.beginPath();
      ctx.arc(mapX(cPt[0]), mapY(cPt[1]), Math.abs(pc.r)*s, -a0, -a1, pc.theta<0); // minus for canvas Y-down
      ctx.stroke();
    }
  }

  // centerlines / item colors
  for(let i=0;i<pieces.length;i++){
    const pc=pieces[i];
    ctx.strokeStyle=COLORS[pc.tCode]||COLORS.line; ctx.lineWidth=3;
    if(pc.type==='line'){
      const x0=mapX(pc.start[0]), y0=mapY(plane==='XY'?pc.start[1]:pc.start[2]);
      const x1=mapX(pc.end[0]),   y1=mapY(plane==='XY'?pc.end[1]:pc.end[2]);
      ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
    }else{
      const sPt=[pc.start[0], plane==='XY'?pc.start[1]:pc.start[2]];
      const cPt=[pc.center[0],plane==='XY'?pc.center[1]:pc.center[2]];
      const a0=Math.atan2(sPt[1]-cPt[1], sPt[0]-cPt[0]);
      const a1=a0 + pc.theta;
      ctx.beginPath();
      ctx.arc(mapX(cPt[0]), mapY(cPt[1]), Math.abs(pc.r)*s, -a0, -a1, pc.theta<0);
      ctx.stroke();
    }
  }

  // item labels at centroids
  ctx.fillStyle='#000'; ctx.font='13px system-ui';
  for(let m=0;m<marks.length;m++){
    const mk=marks[m]; const x=mk[1], y=(plane==='XY'?mk[2]:mk[3]);
    ctx.fillText(String(mk[0]), mapX(x)+4, mapY(y)-16);
  }

  // pick marker
  const pxPick=mapX(p.pickPoint[0]);
  const pyPick=mapY(plane==='XY'?p.pickPoint[1]:p.pickPoint[2]);
  ctx.strokeStyle=COLORS.pick; ctx.fillStyle=COLORS.pick; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(pxPick, pyPick-14); ctx.lineTo(pxPick, pyPick-2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(pxPick, pyPick-2); ctx.lineTo(pxPick-6, pyPick-8); ctx.moveTo(pxPick, pyPick-2); ctx.lineTo(pxPick+6, pyPick-8); ctx.stroke();
  ctx.beginPath(); ctx.arc(pxPick, pyPick, 4, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle='#000'; ctx.font='12px system-ui'; ctx.fillText('Pick', pxPick+6, pyPick-16);

  // border
  ctx.strokeStyle='#cfd4d9'; ctx.lineWidth=1; ctx.strokeRect(rect.x,rect.y,rect.w,rect.h);
}

/* ---------- big roll dial ---------- */
function drawRollDial(cx, cy, r, targetDeg){
  ctx.strokeStyle = COLORS.roll; ctx.lineWidth=3;
  ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();
  ctx.strokeStyle='#999'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx, cy-r); ctx.stroke();
  const a0 = -Math.PI/2; const a1 = a0 + (targetDeg * Math.PI/180);
  ctx.fillStyle='rgba(91,192,255,0.25)';
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,r,a0,a1, targetDeg<0); ctx.closePath(); ctx.fill();
  ctx.strokeStyle=COLORS.roll; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx + r*Math.cos(a1), cy + r*Math.sin(a1)); ctx.stroke();
  ctx.fillStyle='#000'; ctx.font='14px system-ui'; ctx.fillText('Set Pipe Roll', cx-42, cy-r-22);
  ctx.font='18px system-ui'; ctx.fillText((targetDeg>=0?'+':'')+targetDeg.toFixed(1)+'°', cx-24, cy+8);
  ctx.font='12px system-ui'; ctx.fillText('(+Y)', cx-8, cy-r-12);
  ctx.fillText('(−Y)', cx-12, cy+r+2);
}
</script>
</body>
</html>
