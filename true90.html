<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Rigging CG Helper — v10.6 (Dual-Axis Elbows/Tees + Coupling Anchors)</title>
<style>
  :root{
    --bg:#ffffff; --ink:#111; --panel:#f8f9fa; --border:#e9ecef; --accent:#0d6efd;
    --roll:#5bc0ff; --pickL:#ffd60a; --pickR:#32cd32;
    --anchor:#94a3b8;
  }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; color: var(--ink); background: var(--bg); }
  h1 { font-size: 20px; margin: 0 0 10px; display:flex; align-items:center; gap:10px;}
  .badge { display:inline-block; padding:2px 8px; border-radius:999px; background:#d1e7dd; color:#0f5132; font-weight:700; font-size:12px; }
  fieldset { border: 1px solid #ccc; border-radius: 10px; margin: 10px 0; padding: 10px 12px; }
  legend { padding: 0 6px; font-weight: 600; }
  label { display:block; margin:6px 0 2px; font-size:14px; }
  .inline { display:flex; align-items:center; gap:8px; }
  select, input[type="number"], input[type="text"] { width: 100%; font-size: 16px; padding: 10px 12px; box-sizing: border-box; border-radius: 8px; border:1px solid #cfd4d9; }
  .row { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
  .row3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px;}
  .btn { display:inline-block; padding:10px 12px; margin:8px 6px 0 0; border-radius:10px; background:var(--accent); color:#fff; border:none; font-size:16px; cursor:pointer; }
  .btn.secondary { background:#6c757d; }
  .items { margin-top:6px; }
  .item { padding:8px; border:1px dashed #999; border-radius:8px; margin-bottom:8px; font-size:14px; }
  .hint { color:#555; font-size:13px; }
  #sheet { width:100%; max-width:1000px; background:#fff; border:1px solid #ddd; border-radius:8px; display:block; }
  .out { background:var(--panel); padding:12px; border-radius:10px; border:1px solid var(--border); line-height:1.5; font-size:15px; }
  .out h3 { margin:6px 0; font-size:16px; }
  .out ul { margin:6px 0 10px 20px; padding:0; }
  .out li { margin:4px 0; }
  .pill { display:inline-block; padding:2px 8px; border-radius:999px; font-weight:600; font-size:12px; color:#000; vertical-align:baseline; }
  .pill.left { background: var(--pickL); }
  .pill.right{ background: var(--pickR); }
  .pill.roll { background: var(--roll); }
  .muted { color:#444; font-size:13px; }
  #debug { margin-top:6px; font-size:12px; color:#b00020; white-space:pre-wrap; border:1px dashed #ddd; padding:6px; border-radius:6px;}
  .axis-key { font-size:12px; background:#f6f8fa; border:1px solid #e0e0e0; border-radius:8px; padding:8px; line-height:1.35; }
  .axis-key strong{display:inline-block; width:2.4em;}
</style>
</head>
<body>
<h1>Rigging CG Helper — v10.6 <span class="badge" id="badge">JS not ready</span></h1>

<fieldset>
  <legend>Pick setup</legend>
  <div class="row3">
    <label>Pick mode
      <select id="pickMode">
        <option value="2">2 picks</option>
        <option value="4" selected>4-point (two chokers)</option>
      </select>
    </label>
    <label>Pick spacing (in)
      <input id="pickSpacing" type="number" inputmode="decimal" value="72">
      <div class="hint">Used only in 2-point. 4-point uses CG-balanced point picks.</div>
    </label>
    <label>Pick axes
      <select id="pickAxes">
        <option value="AUTO" selected>Auto</option>
        <option value="X">X only</option>
        <option value="Y">Y only</option>
        <option value="Z">Z only</option>
        <option value="XY">X & Y</option>
        <option value="XZ">X & Z</option>
        <option value="YZ">Y & Z</option>
      </select>
    </label>
  </div>
  <div class="row">
    <div class="axis-key">
      <div><strong>X+</strong> left → right</div>
      <div><strong>Y+</strong> toward you &nbsp;&nbsp; <strong>Y−</strong> away from you</div>
      <div><strong>Z+</strong> up &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Z−</strong> down</div>
    </div>
    <div>
      <label class="inline" style="align-items:center; gap:8px; margin-top:8px;">
        <input id="togglePrevCoupling" type="checkbox"> Distances from previous coupling
      </label>
    </div>
  </div>
</fieldset>

<fieldset>
  <legend>Add item</legend>
  <div class="row">
    <label>Item type
      <select id="itemType">
        <option value="P">24&quot; pipe (per-inch)</option>
        <option value="V">24&quot; valve (regular)</option>
        <option value="E">24&quot; 90° elbow</option>
        <option value="F">24&quot; 45° elbow</option>
        <option value="T">24&quot; tee (plain)</option>
        <option value="W">24&quot; tee with valve</option>
        <option value="G">Single 90 with valve</option>
        <option value="X">Custom per-inch</option>
        <option value="Y">Custom fixed</option>
      </select>
    </label>
    <label>Orientation (layman directions)
      <select id="orient">
        <option value="Xp" selected>Right (X+)</option>
        <option value="Xm">Left (X−)</option>
        <option value="Yp">Toward You (Y+)</option>
        <option value="Ym">Away From You (Y−)</option>
        <option value="Zp">Up (Z+)</option>
        <option value="Zm">Down (Z−)</option>
      </select>
    </label>
  </div>

  <div class="row" id="lenRow" style="display:block">
    <label>Length (in)
      <input id="lenIn" type="number" inputmode="decimal" value="60">
    </label>
    <label id="wpiLabel">Weight per inch (lb/in)
      <input id="wpi" type="number" inputmode="decimal" value="8.2">
    </label>
  </div>

  <div class="row" id="fixedRow" style="display:none">
    <label>Total weight (lb)
      <input id="fixedW" type="number" inputmode="decimal" value="0">
    </label>
    <label>Effective length along chosen axis (in)
      <input id="fixedL" type="number" inputmode="decimal" value="0">
    </label>
  </div>

  <div id="single90Row" class="row" style="display:none">
    <label>Straight before 90 (in)
      <input id="s90_before" type="number" inputmode="decimal" value="0">
    </label>
    <label>Extra straight AFTER 90 (in)
      <input id="s90_after" type="number" inputmode="decimal" value="0">
    </label>
    <label>Valve type
      <select id="s90_vtype">
        <option value="S">Standard</option>
      </select>
    </label>
  </div>

  <button class="btn" id="addBtn" type="button">Add item</button>
  <button class="btn secondary" id="removeLastBtn" type="button">Remove last item</button>
  <button class="btn secondary" id="clearBtn" type="button">Clear list</button>

  <div class="items" id="items"></div>
  <div id="debug">debug: (none)</div>
</fieldset>

<button class="btn" id="computeBtn" type="button">Compute + Draw</button>
<button class="btn secondary" id="downloadBtn" type="button" disabled>Download PNG</button>

<fieldset>
  <legend>Output (quick)</legend>
  <div id="summary" class="out"></div>
  <div class="muted">Legend: <span class="pill left">Left</span> <span class="pill right">Right</span> <span class="pill roll">Roll</span></div>
</fieldset>

<fieldset>
  <legend>Drawings</legend>
  <canvas id="sheet"></canvas>
  <div class="muted">Plan (X–Y) & Elevation (X–Z). Labels group by <b>Left</b>/<b>Right</b>; when “prev coupling” is ON, small <span style="color:var(--anchor);font-weight:600">anchor ticks</span> show the measuring point.</div>
</fieldset>

<script>
(function(){ var b=document.getElementById('badge'); if(b) b.textContent='JS Loaded v10.6'; })();

if(!window.__rig_v10_wired){
  window.__rig_v10_wired = true;

  /* Canvas / HiDPI */
  function setupCanvas(canvas, cssW, cssH) {
    cssW = cssW || 1000; cssH = cssH || 1200;
    var dpr = window.devicePixelRatio || 1;
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width  = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    var ctx = canvas.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.textBaseline = 'top';
    return ctx;
  }

  /* Constants */
  var PIPE_DIAM_IN = 24.0;
  var PIPE_R_IN = PIPE_DIAM_IN / 2.0;
  var W_PER_IN_DEFAULT = 8.2;
  var W_EL90=475.0, S_EL90=36.0;
  var W_EL45=240.0, S_EL45=15.0;
  var W_COUP=115.0;
  var W_VALVE_BODY=451.0, L_VALVE_STD=12.0;
  var W_TEE_BODY=477.0, L_TEE=20.0;

  var DEFAULT_PICK_SPACING=72.0;
  var COUP_EXCLUDE_HALF=0.5; // ±0.5" around couplings

  /* Colors */
  var COLORS = {
    axisX:'#d12222', axisY:'#2a9d2a', axisZ:'#1f6feb',
    P:'#666666', E:'#2aa198', F:'#2aa198',
    V:'#ff9100', C:'#8e44ad',
    T:'#d33682', W:'#d33682', G:'#2aa198',
    X:'#8d6e63', Y:'#8d6e63',
    pickLeft: (getComputedStyle(document.documentElement).getPropertyValue('--pickL') || '#ffd60a').trim(),
    pickRight:(getComputedStyle(document.documentElement).getPropertyValue('--pickR') || '#32cd32').trim(),
    pipeBand:'rgba(100,100,100,0.18)',
    centerline:'#000',
    flag:'#d32f2f',
    anchor:(getComputedStyle(document.documentElement).getPropertyValue('--anchor') || '#94a3b8').trim()
  };

  /* Helpers / Vectors */
  var ORIENTS={
    Xp:[1,0,0], Xm:[-1,0,0],
    Yp:[0,1,0], Ym:[0,-1,0],
    Zp:[0,0,1], Zm:[0,0,-1]
  };
  function r1(x){return Math.round(x*10)/10;}
  function r4(x){return Math.round(x*4)/4;}
  function fmtFtIn(x){
    var v=r4(x); var ft=Math.floor(v/12); var rem=v-ft*12;
    var whole=Math.floor(rem); var frac=Math.round((rem-whole)*100)/100;
    var map={"0":"", "0.25":"-1/4", "0.5":"-1/2", "0.75":"-3/4"};
    var tag = map.hasOwnProperty(String(frac)) ? map[String(frac)] : null;
    var inch = tag!==null ? (whole+tag+'"') : (rem.toFixed(2)+'"');
    return ft? (ft+"' "+inch) : inch;
  }
  function vEq(a,b){return a[0]===b[0]&&a[1]===b[1]&&a[2]===b[2];}
  function axisFromDir(d){ return Math.abs(d[0])? 'X' : (Math.abs(d[1])? 'Y' : 'Z'); }
  function orthAxisTo(d){ // pick a perpendicular axis (X->Y, Y->Z, Z->X)
    if(Math.abs(d[0])) return [0,1,0];
    if(Math.abs(d[1])) return [0,0,1];
    return [1,0,0];
  }

  /* State */
  var items=[]; // {name,length,weight,xcg_local,tCode,orientVec:[x,y,z]}
  var segments=[]; // {tCode,start:[x,y,z],end:[x,y,z], drawCode, countJoint:boolean}
  var marks=[];
  var _forbidden = { X:[], Y:[], Z:[] };
  var _nudges=[];
  var ctx, sheet, summaryDiv, itemsDiv, debugDiv;
  var pickModeEl, pickSpacingEl, pickAxesEl, togglePrevCouplingEl;
  var itemTypeEl, orientEl, lenRow, wpiEl, wpiLabel, lenInEl, fixedRow, fixedWEl, fixedLEl;
  var single90Row, s90_beforeEl, s90_afterEl, s90_vtypeEl;

  function el(id){ return document.getElementById(id); }

  /* UI show/hide */
  function updateDetailRows(){
    var t=itemTypeEl.value;
    lenRow.style.display='none'; fixedRow.style.display='none'; single90Row.style.display='none';
    if(t==='P'||t==='X'){ lenRow.style.display='grid'; wpiLabel.style.display='block'; }
    if(t==='Y'){ fixedRow.style.display='grid'; }
    if(t==='G'){ single90Row.style.display='grid'; }
    if(t!=='X') wpiEl.value=W_PER_IN_DEFAULT;
  }

  function addItemSummary(text){
    var d=document.createElement('div'); d.className='item'; d.textContent=text; itemsDiv.appendChild(d);
  }

  function resetAll(){
    items=[]; segments=[]; marks=[]; _forbidden={X:[],Y:[],Z:[]}; _nudges=[];
    itemsDiv.innerHTML=''; summaryDiv.innerHTML='';
    ctx && ctx.clearRect(0,0,sheet.width,sheet.height);
    debugDiv.textContent='debug: reset';
  }
  function removeLast(){
    if(items.length===0) return;
    items.pop();
    // rebuild everything (safer with turns)
    rebuildGeometry();
    redrawDebug();
  }

  /* Geometry builders */
  function getCurrentEnd(){ return segments.length===0?[0,0,0]:segments[segments.length-1].end.slice(); }
  function pushSegment(tCode,dir,L,labelIdx,drawCode,countJoint){
    var start=getCurrentEnd(); var end=[ start[0]+dir[0]*L, start[1]+dir[1]*L, start[2]+dir[2]*L ];
    segments.push({tCode, start, end, drawCode:drawCode||tCode, countJoint: (countJoint!==false) });
    if(labelIdx!=null){
      var mid=[(start[0]+end[0])/2,(start[1]+end[1])/2,(start[2]+end[2])/2];
      marks.push([labelIdx,mid[0],mid[1],mid[2]]);
    }
  }

  function itemWeightText(idx, label, L, W){
    return idx+'. '+label+' L='+L.toFixed(1)+' in, W='+W.toFixed(1)+' lb';
  }

  function addItem(){
    try{
      var t=itemTypeEl.value; var idx=items.length+1;
      var okey=orientEl.value; var ovec=ORIENTS[okey]||[1,0,0];

      function placeLinear(name,L,W,xcgLocal,tCode){
        L=Math.max(0, Number(L)||0);
        if(xcgLocal==null) xcgLocal=L/2;
        items.push({name,length:L,weight:W,xcg_local:xcgLocal,tCode,orientVec:ovec});
        addItemSummary(itemWeightText(idx, name, L, W));
        rebuildGeometry(); // rebuild path with auto-turns
        redrawDebug();
      }

      if(t==='P'){
        var L=Number(lenInEl.value)||0, wpi=Number(wpiEl.value)||W_PER_IN_DEFAULT; var W=wpi*L;
        placeLinear('24" pipe (per-inch)',L,W,null,'P');

      }else if(t==='X'){
        var Lx=Number(lenInEl.value)||0, wpiX=Number(wpiEl.value)||W_PER_IN_DEFAULT; var WX=wpiX*Lx;
        placeLinear('Custom per-inch',Lx,WX,null,'X');

      }else if(t==='Y'){
        var WY=Number(fixedWEl.value)||0, LY=Number(fixedLEl.value)||0;
        placeLinear('Custom fixed',LY,WY,null,'Y');

      }else if(t==='V'){
        var LV=L_VALVE_STD, WV=W_VALVE_BODY;
        placeLinear('24" valve (regular)',LV,WV,LV/2,'V');

      }else if(t==='E'){
        var LE=S_EL90, WE=W_EL90;
        placeLinear('24" 90° elbow',LE,WE,LE/2,'E');

      }else if(t==='F'){
        var LF=S_EL45, WF=W_EL45;
        placeLinear('24" 45° elbow',LF,WF,LF/2,'F');

      }else if(t==='T'){
        var LT=L_TEE, WT=W_TEE_BODY;
        placeLinear('24" tee (plain)',LT,WT,LT/2,'T');

      }else if(t==='W'){
        var LW=L_TEE;
        var WW = W_TEE_BODY + W_VALVE_BODY;
        // CG approx at mid
        placeLinear('24" tee with valve',LW,WW,LW/2,'W');

      }else if(t==='G'){
        var LG=S_EL90, WG=W_EL90+W_VALVE_BODY;
        placeLinear('Single 90 with valve',LG,WG,LG/2,'G');
      }

    }catch(err){
      debugDiv.textContent = 'debug: Add item failed: ' + (err && err.message ? err.message : err);
    }
  }

  /* Auto-turn logic: build segments from items
     - Keep a running direction 'dir' (start with first item's orient).
     - E (90°) is split into two legs: leg1 along current dir, leg2 turns toward next item's orient axis (auto).
     - T/ W (tee) draws straight along current dir, and adds a short branch stub toward next item's orient axis (auto).
     - F (45°) left as straight for now (can expand later).
     - Internal elbow leg split does NOT count a coupling at the split.
  */
  function rebuildGeometry(){
    segments=[]; marks=[];
    if(items.length===0) return;

    // Starting direction = first item's orient
    var dir = items[0].orientVec.slice();

    for(var i=0;i<items.length;i++){
      var it=items[i];
      var nextDir = (i<items.length-1)? items[i+1].orientVec.slice() : dir.slice(); // default: continue

      // If nextDir is collinear with dir, and we need a perpendicular for a tee stub, pick orthAxis later.
      if(it.tCode==='E' || it.tCode==='G'){
        // 90° elbow (or 90 with valve) -> two legs
        var L=it.length, half=L/2;
        // leg1: along incoming dir
        pushSegment(it.tCode, dir, half, i+1, it.tCode, true);
        // leg2: turn toward next item's axis (auto)
        var turnOut = vEq(nextDir,dir)? orthAxisTo(dir) : nextDir.slice();
        pushSegment(it.tCode, turnOut, half, null, it.tCode, false); // internal split, no coupling
        // Update run direction to outgoing
        dir = turnOut.slice();

      }else if(it.tCode==='T' || it.tCode==='W'){
        // Main body along current run
        pushSegment(it.tCode, dir, it.length, i+1, it.tCode, true);
        // Add branch stub perpendicular toward next item's axis
        var stubDir = vEq(nextDir,dir)? orthAxisTo(dir) : nextDir.slice();
        // Short visual stub (half body length)
        var stubLen = it.length/2;
        // Save & restore current end: draw stub off the midpoint visually (don’t advance the path)
        var curEnd = getCurrentEnd().slice();
        // Move back half to tee midpoint
        var midBack = [-dir[0]*it.length/2, -dir[1]*it.length/2, -dir[2]*it.length/2];
        var teeMidStart = [curEnd[0]+midBack[0], curEnd[1]+midBack[1], curEnd[2]+midBack[2]];
        // Temporarily set current end to tee midpoint for stub draw
        var originalEnd = segments.length? segments[segments.length-1].end.slice():[0,0,0];
        segments.length && (segments[segments.length-1].end = teeMidStart.slice());
        pushSegment('T_stub', stubDir, stubLen, null, 'T', false);
        // Restore main path end
        segments.length && (segments[segments.length-1].end = curEnd.slice());
        // Continue straight
        // dir unchanged

      }else{
        // Straight items
        pushSegment(it.tCode, dir, it.length, i+1, it.tCode, true);
        // If the item itself has an orientation different from current direction (custom fixed, etc.), allow a change after it
        if(!vEq(it.orientVec, dir)){
          dir = it.orientVec.slice();
        }
      }
    }

    rebuildForbidden(); // refresh forbidden from new segment list
  }

  /* Forbidden zones (valves/tees/couplings) */
  function rebuildForbidden(){
    _forbidden={X:[],Y:[],Z:[]};
    function addF(axis, a, b){ if(a>b){var t=a;a=b;b=t;} _forbidden[axis].push([a,b]); }

    // Couplings at true item joints only (segment boundaries with countJoint=true)
    for(var i=0;i<segments.length;i++){
      var s=segments[i];
      if(!s.countJoint) continue;
      // count start
      [['X',0],['Y',1],['Z',2]].forEach(function(t){
        var p=s.start[t[1]];
        addF(t[0], p-COUP_EXCLUDE_HALF, p+COUP_EXCLUDE_HALF);
      });
      // count end
      [['X',0],['Y',1],['Z',2]].forEach(function(t){
        var p=s.end[t[1]];
        addF(t[0], p-COUP_EXCLUDE_HALF, p+COUP_EXCLUDE_HALF);
      });
    }

    // Item bodies for valves and tees (main run axis only)
    for(var k=0;k<items.length;k++){
      var it=items[k];

      // Find the segment that carries its label (marks index==k)
      var segIdx = -1, seg;
      for(var s=0,seen=0;s<segments.length;s++){
        // marks are pushed with label index i+1 on the segment representing the item body
        // We can approximate by first segment with drawCode == it.tCode and countJoint==true after the last seen
        if(segments[s].drawCode===it.tCode && segments[s].countJoint){
          seen++;
          if(seen===1){ segIdx=s; break; }
        }
      }
      seg = segIdx>=0? segments[segIdx] : null;
      if(!seg) continue;

      var ax = axisFromDir([seg.end[0]-seg.start[0], seg.end[1]-seg.start[1], seg.end[2]-seg.start[2]]);
      var sel = (ax==='X'?0:(ax==='Y'?1:2));
      var segMin = Math.min(seg.start[sel], seg.end[sel]);
      var segMax = Math.max(seg.start[sel], seg.end[sel]);
      var mid = (seg.start[sel]+seg.end[sel])/2;

      if(it.name.indexOf('valve')>=0 && it.tCode!=='W'){ addF(ax, segMin, segMax); }
      if(it.tCode==='T' || it.tCode==='W'){
        // center 24" of tee along run axis
        var a=mid-12, b=mid+12; addF(ax, Math.max(a,segMin), Math.min(b,segMax));
      }
    }

    // Merge per axis
    ['X','Y','Z'].forEach(function(A){
      var arr=_forbidden[A]; if(arr.length<=1) return;
      arr.sort(function(p,q){return p[0]-q[0];});
      var merged=[arr[0]];
      for(var i=1;i<arr.length;i++){
        var last=merged[merged.length-1], cur=arr[i];
        if(cur[0] <= last[1]+1e-6){ last[1]=Math.max(last[1],cur[1]); }
        else merged.push(cur);
      }
      _forbidden[A]=merged;
    });
  }

  function redrawDebug(){
    debugDiv.textContent = 'debug: items='+items.length+'; segments='+segments.length+
      '; forb X='+_forbidden.X.length+' Y='+_forbidden.Y.length+' Z='+_forbidden.Z.length;
  }

  /* Joints on an axis + previous-coupling distance */
  function jointsOnAxis(sel){
    var st=new Set();
    for(var i=0;i<segments.length;i++){
      var s=segments[i];
      if(s.countJoint){ st.add(s.start[sel]); st.add(s.end[sel]); }
    }
    var arr=Array.from(st); arr.sort(function(a,b){return a-b;}); return arr;
  }
  function prevCouplingDist(axis, x, ex){
    var sel = (axis==='X'?0:(axis==='Y'?1:2));
    var joints = jointsOnAxis(sel);
    var prev = ex.min; // fallback to min edge if none
    for(var i=0;i<joints.length;i++){ if(joints[i] <= x) prev = joints[i]; else break; }
    return {anchor:prev, dist: x - prev};
  }

  function adjustAwayFromForbidden(axis, x){
    var forb = _forbidden[axis];
    for(var i=0;i<forb.length;i++){
      var a=forb[i][0], b=forb[i][1];
      if(x>=a-1e-6 && x<=b+1e-6){
        var toA=Math.abs(x-a), toB=Math.abs(b-x);
        var nx = (toA<=toB? a-1e-6 : b+1e-6);
        _nudges.push({axis:axis, from:x, to:nx});
        return nx;
      }
    }
    return x;
  }

  function axisExt(sel){
    var arr=[]; for(var k=0;k<segments.length;k++){ arr.push(segments[k].start[sel],segments[k].end[sel]); }
    if(arr.length===0) arr=[0];
    var min=Math.min.apply(null,arr), max=Math.max.apply(null,arr);
    return {min:min,max:max,span:(max-min)};
  }

  /* Compute + Draw */
  function computeAndDraw(){
    if(items.length===0){ alert('Add at least one item.'); return; }

    var pickMode=pickModeEl.value;
    var pickAxesSel=pickAxesEl.value;
    var pickSpacing=Math.max(0, Number(pickSpacingEl.value)||DEFAULT_PICK_SPACING);
    var usePrevCoupling = togglePrevCouplingEl.checked;

    // Weighted CG (items + couplings at true joints)
    var totalW=0, sumX=0, sumY=0, sumZ=0;
    for(var i=0;i<items.length;i++){
      var it=items[i];
      // approximate item CG from segment representing its body:
      // find first segment with drawCode == it.tCode and countJoint==true after previous
      var found=null, seen=0;
      for(var s=0;s<segments.length;s++){
        var sg=segments[s];
        if(sg.drawCode===it.tCode && sg.countJoint){ found=sg; break; }
      }
      var m;
      if(found){
        m=[0,(found.start[0]+found.end[0])/2,(found.start[1]+found.end[1])/2,(found.start[2]+found.end[2])/2];
      }else{
        // fallback to global origin
        m=[0,0,0,0];
      }
      totalW += it.weight; sumX += it.weight*m[1]; sumY += it.weight*m[2]; sumZ += it.weight*m[3];
    }
    // Add couplings at true joints
    for(var j=0;j<segments.length;j++){
      var s=segments[j]; if(!s.countJoint) continue;
      // avoid double counting same coordinate: simple add for end points
      totalW += W_COUP; sumX += W_COUP*s.end[0]; sumY += W_COUP*s.end[1]; sumZ += W_COUP*s.end[2];
    }
    var cg={ X:(totalW?sumX/totalW:0), Y:(totalW?sumY/totalW:0), Z:(totalW?sumZ/totalW:0) };

    var ext={ X:axisExt(0), Y:axisExt(1), Z:axisExt(2) };
    window.v10Last = { cg: cg, ext: ext };

    _nudges=[];

    function chooseAxes(){
      if(pickAxesSel==='X' || pickAxesSel==='Y' || pickAxesSel==='Z'){ return [pickAxesSel]; }
      if(pickAxesSel==='XY' || pickAxesSel==='XZ' || pickAxesSel==='YZ'){ return pickAxesSel.split(''); }
      var spans=[['X',ext.X.span],['Y',ext.Y.span],['Z',ext.Z.span]].sort(function(a,b){return b[1]-a[1];});
      if(pickMode==='2'){ return [spans[0][0]]; }
      var axes=[]; for(var s=0;s<spans.length && axes.length<2;s++){ if(spans[s][1]>0) axes.push(spans[s][0]); }
      if(axes.length===0) axes=['X']; return axes;
    }
    function balancedPoints(axis){
      var ex=ext[axis], cgA=cg[axis];
      var left = (ex.min + cgA)/2;
      var right = (cgA + ex.max)/2;
      if(right<=left){ right = left + 1; }
      left  = Math.max(ex.min, Math.min(ex.max, left));
      right = Math.max(ex.min, Math.min(ex.max, right));
      left  = adjustAwayFromForbidden(axis, left);
      right = adjustAwayFromForbidden(axis, right);
      if(right<=left){ right = left + 1; }
      return {left:left, right:right, ex:ex};
    }

    var selectedAxes = chooseAxes();
    var picksets = selectedAxes.map(function(axis){
      var ex=ext[axis];
      if(pickMode==='2'){
        var left = Math.max(ex.min, Math.min(ex.max - pickSpacing, cg[axis] - pickSpacing/2));
        var right = left + pickSpacing;
        if(right>ex.max){ right=ex.max; left=Math.max(ex.min, right - pickSpacing); }
        left  = adjustAwayFromForbidden(axis, left);
        right = adjustAwayFromForbidden(axis, right);
        if(right<=left){ right = left + 1; }
        return {mode:'2', axis:axis, picks:[left,right], ex:ex};
      }else{
        var bp = balancedPoints(axis);
        return {mode:'4', axis:axis, picks:[bp.left,bp.right], ex:bp.ex, autoBalanced:true};
      }
    });

    // Output summary (grouped by choker)
    function fmtInches(x){ return r1(x).toFixed(1) + '"'; }
    function distanceLine(axis, pos, ex){
      if(usePrevCoupling){
        var d=prevCouplingDist(axis,pos,ex);
        return fmtInches(d.dist)+' from prev coupling';
      }else{
        return fmtInches(pos - ex.min)+' from min '+axis+' edge';
      }
    }
    var html='';
    html += '<h3>Rigging Summary</h3><ul>';
    var itemsWeight = items.reduce(function(a,it){return a+it.weight;},0);
    var jointsCount = segments.filter(s=>s.countJoint).length;
    var couplingsWeight = jointsCount * W_COUP;
    var totalWeight = itemsWeight + couplingsWeight;
    html += '<li>Total weight: <b>'+totalWeight.toFixed(1)+' lb</b> (items '+itemsWeight.toFixed(1)+' + couplings '+couplingsWeight.toFixed(1)+' ['+jointsCount+'×])</li>';
    html += '<li>CG (true 3D): X=<b>'+cg.X.toFixed(2)+' in</b>, Y=<b>'+cg.Y.toFixed(2)+' in</b>, Z=<b>'+cg.Z.toFixed(2)+' in</b></li>';
    html += '<li>Distance reference: <b>'+(usePrevCoupling?'Previous coupling':'Min axis edge')+'</b></li>';
    html += '</ul>';

    var leftLines=[], rightLines=[];
    picksets.forEach(function(ps){
      var axis=ps.axis, ex=ps.ex;
      leftLines.push(axis+': '+distanceLine(axis, ps.picks[0], ex));
      rightLines.push(axis+': '+distanceLine(axis, ps.picks[1], ex));
    });
    html += '<h3>Chokers</h3><ul>';
    html += '<li><span class="pill left">Left</span> '+leftLines.join(' &nbsp;•&nbsp; ')+'</li>';
    html += '<li><span class="pill right">Right</span> '+rightLines.join(' &nbsp;•&nbsp; ')+'</li>';
    html += '</ul>';

    var roll_deg = (PIPE_R_IN>0)? (Math.asin(Math.max(-1,Math.min(1, cg.Y/PIPE_R_IN)))*180/Math.PI) : 0;
    var roll_side=cg.Y>0?'toward +Y':(cg.Y<0?'toward -Y':'no roll needed');
    var arc_in=PIPE_R_IN*(Math.abs(roll_deg)*Math.PI/180);
    html += '<h3>Roll</h3><ul>';
    html += '<li><span class="pill roll">Roll</span> chokers: ~'+roll_deg.toFixed(1)+'° '+roll_side+'</li>';
    html += '<li><span class="pill roll">Roll</span> circumference offset per choker: '+fmtFtIn(arc_in)+'</li>';
    if(_nudges.length){ html += '<li class="muted">Adjusted off forbidden zones '+_nudges.length+' time(s).</li>'; }
    html += '</ul>';

    summaryDiv.innerHTML = html;

    drawSheet(picksets, usePrevCoupling);
    el('downloadBtn').disabled=false;
  }

  /* Drawing */
  function drawSheet(picksets, usePrevCoupling){
    ctx=setupCanvas(sheet, 1000, 1200);
    var W=1000,H=1200,pad=28;
    var secH=Math.floor((H-pad*4)/2);
    var planRect={x:pad,y:pad,w:W-2*pad,h:secH};
    var elevRect={x:pad,y:pad*2+secH,w:W-2*pad,h:secH};

    ctx.fillStyle='#fff'; ctx.fillRect(0,0,W,H);

    // Build vertex lists for extents
    var verts=[[0,0,0]];
    for(var i=0;i<segments.length;i++){ verts.push( segments[i].end.slice() ); }
    var px=verts.map(v=>v[0]), py=verts.map(v=>v[1]), pz=verts.map(v=>v[2]);

    drawProjection(planRect,px,py,'Plan (X–Y)',picksets,'XY',usePrevCoupling);
    drawProjection(elevRect,px,pz,'Elevation (X–Z)',picksets,'XZ',usePrevCoupling);
  }

  function drawProjection(rect,px,py,title,picksets,plane,usePrevCoupling){
    var minX=Math.min.apply(null, px.concat([0])), maxX=Math.max.apply(null, px.concat([1]));
    var minY=Math.min.apply(null, py.concat([-1])), maxY=Math.max.apply(null, py.concat([1]));

    var pad=46;
    var sx=(rect.w-pad*2)/((maxX-minX)||1);
    var sy=(rect.h-pad*2)/((maxY-minY)||1);
    var s=Math.min(sx,sy);
    function mapX(x){ return rect.x+pad+(x-minX)*s; }
    function mapY(y){ return rect.y+rect.h-pad-(y-minY)*s; }

    ctx.fillStyle='#000'; ctx.font='20px system-ui';
    ctx.fillText(title, rect.x, rect.y-6);

    // Axes
    ctx.lineWidth=2;
    ctx.strokeStyle=COLORS.axisX; ctx.beginPath(); ctx.moveTo(mapX(minX), mapY(0)); ctx.lineTo(mapX(maxX), mapY(0)); ctx.stroke();
    ctx.strokeStyle=(plane==='XY')?COLORS.axisY:COLORS.axisZ;
    var x0=mapX(0); ctx.beginPath(); ctx.moveTo(x0,mapY(minY)); ctx.lineTo(x0,mapY(maxY)); ctx.stroke();

    var thickness=Math.min(30, Math.max(8, s*24*0.6));
    ctx.lineCap='round';

    // Pipe bands & centerlines (drawCode guides color)
    for(var i=0;i<segments.length;i++){
      var seg=segments[i];
      var aX=seg.start[0], aY=(plane==='XY'? seg.start[1]:seg.start[2]);
      var bX=seg.end[0],   bY=(plane==='XY'? seg.end[1]  :seg.end[2] );
      ctx.strokeStyle=COLORS.pipeBand; ctx.lineWidth=thickness; ctx.beginPath(); ctx.moveTo(mapX(aX),mapY(aY)); ctx.lineTo(mapX(bX),mapY(bY)); ctx.stroke();
    }
    for(var j=0;j<segments.length;j++){
      var sg=segments[j];
      var aX2=sg.start[0], aY2=(plane==='XY'? sg.start[1]:sg.start[2]);
      var bX2=sg.end[0],   bY2=(plane==='XY'? sg.end[1]  :sg.end[2] );
      var clr = COLORS[sg.drawCode]||COLORS.centerline;
      ctx.strokeStyle=clr; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(mapX(aX2),mapY(aY2)); ctx.lineTo(mapX(bX2),mapY(bY2)); ctx.stroke();
    }

    // Item index labels (on the segment where they were attached)
    ctx.fillStyle='#000'; ctx.font='14px system-ui';
    for(var m=0;m<marks.length;m++){
      var mk=marks[m];
      var x=mk[1], y=(plane==='XY'? mk[2] : mk[3]);
      ctx.fillText(String(mk[0]), mapX(x)+4, mapY(y)-16);
    }

    // ===== Grouped top pills by choker =====
    var topY=rect.y+10;
    function topLabelX(next){ var x=rect.x+12+next; var w=160; return [x,w]; }
    var nextLabelOffset=0;

    function r10(x){ return Math.round(x*10)/10; }
    function distText(axis, pos, ex){
      if(usePrevCoupling){
        var d=prevCouplingDist(axis,pos,ex);
        return r10(d.dist).toFixed(1) + '"';
      }else{
        return r10(pos - ex.min).toFixed(1) + '"';
      }
    }
    function anchorAt(axis, pos, ex){
      var d=prevCouplingDist(axis,pos,ex);
      return d.anchor;
    }

    var byAxis = {}; picksets.forEach(ps=>byAxis[ps.axis]=ps);

    // LEFT
    var dimsL = topLabelX(nextLabelOffset);
    drawTopPill(dimsL[0],topY-8,dimsL[1],22,COLORS.pickLeft,'Left choker');
    nextLabelOffset += dimsL[1]+12;

    if(plane==='XY'){
      if(byAxis.X){ var p=byAxis.X, ax='X', ex=p.ex;
        drawLeader(dimsL[0]+dimsL[1]/2,topY+10,mapX(p.picks[0]),mapY(0),COLORS.pickLeft);
        drawPickMarker(mapX(p.picks[0]),mapY(0),COLORS.pickLeft,'L');
        // label + anchor tick
        var txt = distText(ax, p.picks[0], ex) + ' from ' + (usePrevCoupling?'prev cplg':'min X');
        ctx.fillStyle='#111'; ctx.font='12px system-ui'; ctx.fillText(txt, mapX(p.picks[0])+6, mapY(0)-18);
        if(usePrevCoupling){ drawAnchorTickX(mapX(anchorAt(ax,p.picks[0],ex)), mapY(0)); }
      }
      if(byAxis.Y){ var p=byAxis.Y, ax='Y', ex=p.ex;
        drawLeader(dimsL[0]+dimsL[1]/2,topY+10,mapX(0),mapY(p.picks[0]),COLORS.pickLeft);
        drawPickMarker(mapX(0),mapY(p.picks[0]),COLORS.pickLeft,'L');
        var txt2 = distText(ax, p.picks[0], ex) + ' from ' + (usePrevCoupling?'prev cplg':'min Y');
        ctx.fillStyle='#111'; ctx.font='12px system-ui'; ctx.fillText(txt2, mapX(0)+6, mapY(p.picks[0])-18);
        if(usePrevCoupling){ drawAnchorTickY(mapX(0), mapY(anchorAt(ax,p.picks[0],ex))); }
      }
    }else{ // XZ
      if(byAxis.X){ var p=byAxis.X, ax='X', ex=p.ex;
        drawLeader(dimsL[0]+dimsL[1]/2,topY+10,mapX(p.picks[0]),mapY(0),COLORS.pickLeft);
        drawPickMarker(mapX(p.picks[0]),mapY(0),COLORS.pickLeft,'L');
        var t3 = distText(ax, p.picks[0], ex) + ' from ' + (usePrevCoupling?'prev cplg':'min X');
        ctx.fillStyle='#111'; ctx.font='12px system-ui'; ctx.fillText(t3, mapX(p.picks[0])+6, mapY(0)-18);
        if(usePrevCoupling){ drawAnchorTickX(mapX(anchorAt(ax,p.picks[0],ex)), mapY(0)); }
      }
      if(byAxis.Z){ var p=byAxis.Z, ax='Z', ex=p.ex;
        drawLeader(dimsL[0]+dimsL[1]/2,topY+10,mapX(0),mapY(p.picks[0]),COLORS.pickLeft);
        drawPickMarker(mapX(0),mapY(p.picks[0]),COLORS.pickLeft,'L');
        var t4 = distText(ax, p.picks[0], ex) + ' from ' + (usePrevCoupling?'prev cplg':'min Z');
        ctx.fillStyle='#111'; ctx.font='12px system-ui'; ctx.fillText(t4, mapX(0)+6, mapY(p.picks[0])-18);
        if(usePrevCoupling){ drawAnchorTickY(mapX(0), mapY(anchorAt(ax,p.picks[0],ex))); }
      }
    }

    // RIGHT
    var dimsR = topLabelX(nextLabelOffset);
    drawTopPill(dimsR[0],topY-8,dimsR[1],22,COLORS.pickRight,'Right choker');
    nextLabelOffset += dimsR[1]+12;

    if(plane==='XY'){
      if(byAxis.X){ var p=byAxis.X, ax='X', ex=p.ex;
        drawLeader(dimsR[0]+dimsR[1]/2,topY+10,mapX(p.picks[1]),mapY(0),COLORS.pickRight);
        drawPickMarker(mapX(p.picks[1]),mapY(0),COLORS.pickRight,'R');
        var txtr = distText(ax, p.picks[1], ex) + ' from ' + (usePrevCoupling?'prev cplg':'min X');
        ctx.fillStyle='#111'; ctx.font='12px system-ui'; ctx.fillText(txtr, mapX(p.picks[1])+6, mapY(0)-18);
        if(usePrevCoupling){ drawAnchorTickX(mapX(anchorAt(ax,p.picks[1],ex)), mapY(0)); }
      }
      if(byAxis.Y){ var p=byAxis.Y, ax='Y', ex=p.ex;
        drawLeader(dimsR[0]+dimsR[1]/2,topY+10,mapX(0),mapY(p.picks[1]),COLORS.pickRight);
        drawPickMarker(mapX(0),mapY(p.picks[1]),COLORS.pickRight,'R');
        var txtr2 = distText(ax, p.picks[1], ex) + ' from ' + (usePrevCoupling?'prev cplg':'min Y');
        ctx.fillStyle='#111'; ctx.font='12px system-ui'; ctx.fillText(txtr2, mapX(0)+6, mapY(p.picks[1])-18);
        if(usePrevCoupling){ drawAnchorTickY(mapX(0), mapY(anchorAt(ax,p.picks[1],ex))); }
      }
    }else{
      if(byAxis.X){ var p=byAxis.X, ax='X', ex=p.ex;
        drawLeader(dimsR[0]+dimsR[1]/2,topY+10,mapX(p.picks[1]),mapY(0),COLORS.pickRight);
        drawPickMarker(mapX(p.picks[1]),mapY(0),COLORS.pickRight,'R');
        var t3r = distText(ax, p.picks[1], ex) + ' from ' + (usePrevCoupling?'prev cplg':'min X');
        ctx.fillStyle='#111'; ctx.font='12px system-ui'; ctx.fillText(t3r, mapX(p.picks[1])+6, mapY(0)-18);
        if(usePrevCoupling){ drawAnchorTickX(mapX(anchorAt(ax,p.picks[1],ex)), mapY(0)); }
      }
      if(byAxis.Z){ var p=byAxis.Z, ax='Z', ex=p.ex;
        drawLeader(dimsR[0]+dimsR[1]/2,topY+10,mapX(0),mapY(p.picks[1]),COLORS.pickRight);
        drawPickMarker(mapX(0),mapY(p.picks[1]),COLORS.pickRight,'R');
        var t4r = distText(ax, p.picks[1], ex) + ' from ' + (usePrevCoupling?'prev cplg':'min Z');
        ctx.fillStyle='#111'; ctx.font='12px system-ui'; ctx.fillText(t4r, mapX(0)+6, mapY(p.picks[1])-18);
        if(usePrevCoupling){ drawAnchorTickY(mapX(0), mapY(anchorAt(ax,p.picks[1],ex))); }
      }
    }

    ctx.strokeStyle='#cfd4d9'; ctx.lineWidth=1; ctx.strokeRect(rect.x,rect.y,rect.w,rect.h);

    // Small helpers for anchor ticks
    function drawAnchorTickX(px, py){ ctx.strokeStyle=COLORS.anchor; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(px, py-10); ctx.lineTo(px, py+10); ctx.stroke(); }
    function drawAnchorTickY(px, py){ ctx.strokeStyle=COLORS.anchor; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(px-10, py); ctx.lineTo(px+10, py); ctx.stroke(); }
  }

  function drawTopPill(x,y,w,h,color,label){
    ctx.fillStyle=color; ctx.strokeStyle=color; var r=h/2;
    ctx.beginPath();
    ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y);
    ctx.arc(x+w-r,y+r,r,-Math.PI/2,Math.PI/2);
    ctx.lineTo(x+r,y+h); ctx.arc(x+r,y+r,r,Math.PI/2,Math.PI*1.5);
    ctx.closePath(); ctx.fill(); ctx.fillStyle='#000'; ctx.font='13px system-ui'; ctx.fillText(label,x+8,y+4);
  }
  function drawLeader(x1,y1,x2,y2,color){
    ctx.strokeStyle=color; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  }
  function drawPickMarker(x,y,color,label){
    ctx.strokeStyle=color; ctx.fillStyle=color;
    ctx.beginPath(); ctx.moveTo(x,y-16); ctx.lineTo(x,y-2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x,y-2); ctx.lineTo(x-6,y-10); ctx.moveTo(x,y-2); ctx.lineTo(x+6,y-10); ctx.stroke();
    ctx.beginPath(); ctx.arc(x,y,4,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#000'; ctx.font='12px system-ui'; ctx.fillText(label,x+6,y-18);
  }

  /* Wire UI */
  function wireOnce(){
    var addBtn = el('addBtn'); if(addBtn && !addBtn.dataset.bound){ addBtn.dataset.bound='1'; addBtn.addEventListener('click', addItem); }
    var clearBtn = el('clearBtn'); if(clearBtn && !clearBtn.dataset.bound){ clearBtn.dataset.bound='1'; clearBtn.addEventListener('click', resetAll); }
    var removeBtn = el('removeLastBtn'); if(removeBtn && !removeBtn.dataset.bound){ removeBtn.dataset.bound='1'; removeBtn.addEventListener('click', removeLast); }
    var computeBtn = el('computeBtn'); if(computeBtn && !computeBtn.dataset.bound){ computeBtn.dataset.bound='1'; computeBtn.addEventListener('click', computeAndDraw); }
    var downloadBtn = el('downloadBtn'); if(downloadBtn && !downloadBtn.dataset.bound){
      downloadBtn.dataset.bound='1';
      downloadBtn.addEventListener('click', function(){
        var a=document.createElement('a'); var ts=new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
        a.download=ts+'_rigging.png'; a.href=el('sheet').toDataURL('image/png'); a.click();
      });
    }
  }

  window.addEventListener('load', function(){
    pickModeEl=el('pickMode'); pickSpacingEl=el('pickSpacing'); pickAxesEl=el('pickAxes'); togglePrevCouplingEl=el('togglePrevCoupling');
    itemTypeEl=el('itemType'); orientEl=el('orient'); lenRow=el('lenRow'); wpiEl=el('wpi'); wpiLabel=el('wpiLabel'); lenInEl=el('lenIn');
    fixedRow=el('fixedRow'); fixedWEl=el('fixedW'); fixedLEl=el('fixedL');
    single90Row=el('single90Row'); s90_beforeEl=el('s90_before'); s90_afterEl=el('s90_after'); s90_vtypeEl=el('s90_vtype');
    itemsDiv=el('items'); summaryDiv=el('summary'); sheet=el('sheet'); debugDiv=el('debug');

    setupCanvas(sheet);
    itemTypeEl.addEventListener('change', updateDetailRows);
    updateDetailRows();
    wireOnce();

    debugDiv.textContent='debug: ready (v10.6)';
  });
}
</script>
</body>
</html>
