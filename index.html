<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Rigging CG Helper</title>
<style>
  :root{
    --bg:#ffffff; --ink:#111; --panel:#f8f9fa; --border:#e9ecef; --accent:#0d6efd;
  }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; color: var(--ink); background: var(--bg);}
  h1 { font-size: 18px; margin: 0 0 10px; }
  fieldset { border: 1px solid #ccc; border-radius: 10px; margin: 10px 0; padding: 10px 12px; }
  legend { padding: 0 6px; font-weight: 600; }
  label { display: block; margin: 6px 0 2px; font-size: 14px; }
  select, input[type="number"], input[type="text"] { width: 100%; font-size: 16px; padding: 10px 12px; box-sizing: border-box; border-radius: 8px; border:1px solid #cfd4d9; }
  .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
  .btn { display: inline-block; padding: 10px 12px; margin: 8px 6px 0 0; border-radius: 10px; background: var(--accent); color: #fff; border: none; font-size: 16px; }
  .btn.secondary { background: #6c757d; }
  .items { margin-top: 6px; }
  .item { padding: 8px; border: 1px dashed #999; border-radius: 8px; margin-bottom: 8px; font-size: 14px; }
  .hint { color: #555; font-size: 13px; }
  canvas { width: 100%; max-width: 1000px; background: #fff; border: 1px solid #ddd; border-radius: 8px; }
  .out { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background: var(--panel); padding: 12px; border-radius: 10px; border: 1px solid var(--border); line-height: 1.3; }
  .small { font-size:12px; color:#666; }
</style>
</head>
<body>
<h1>Rigging CG Helper</h1>

<fieldset>
  <legend>Pick setup</legend>
  <div class="row">
    <label>Pick mode
      <select id="pickMode">
        <option value="2">2 picks</option>
        <option value="4">4 contacts (two baskets)</option>
      </select>
    </label>
    <label>Pick spacing (in)
      <input id="pickSpacing" type="number" inputmode="decimal" value="72">
    </label>
  </div>
  <div class="row" id="basketRow" style="display:none">
    <label>Basket spread per side (in)
      <input id="basketSpread" type="number" inputmode="decimal" value="12">
    </label>
    <label>No-roll torque threshold (ft-lb, optional)
      <input id="rollThresh" type="number" inputmode="decimal" placeholder="">
    </label>
  </div>
  <div class="hint">Arrowheads mark pick/contacts at Y=0 lines. Pipe shown with thickness for depth.</div>
</fieldset>

<fieldset>
  <legend>Add item</legend>
  <div class="row">
    <label>Item type
      <select id="itemType">
        <option value="P">24" pipe (per-inch)</option>
        <option value="V">24" valve (regular)</option>
        <option value="I">24" valve inline</option>
        <option value="C">24" coupling (weight only)</option>
        <option value="E">24" 90° elbow</option>
        <option value="F">24" 45° elbow</option>
        <option value="T">24" tee (plain)</option>
        <option value="W">24" tee with valve</option>
        <option value="G">Single 90 with valve</option>
        <option value="X">Custom per-inch</option>
        <option value="Y">Custom fixed</option>
      </select>
    </label>
    <label>Orientation (A=X+, B=X−, C=Y+, D=Y−, E=Z+, F=Z−)
      <select id="orient">
        <option value="A" selected>A (X+)</option>
        <option value="B">B (X−)</option>
        <option value="C">C (Y+)</option>
        <option value="D">D (Y−)</option>
        <option value="E">E (Z+)</option>
        <option value="F">F (Z−)</option>
      </select>
    </label>
  </div>

  <!-- dynamic detail row switches per type -->
  <div class="row" id="lenRow" style="display:block">
    <label>Length (in)
      <input id="lenIn" type="number" inputmode="decimal" value="0">
    </label>
    <label id="wpiLabel">Weight per inch (lb/in)
      <input id="wpi" type="number" inputmode="decimal" value="8.2">
    </label>
  </div>

  <div class="row" id="fixedRow" style="display:none">
    <label>Total weight (lb)
      <input id="fixedW" type="number" inputmode="decimal" value="0">
    </label>
    <label>Effective length along chosen axis (in)
      <input id="fixedL" type="number" inputmode="decimal" value="0">
    </label>
  </div>

  <div id="single90Row" class="row" style="display:none">
    <label>Straight before 90 (in)
      <input id="s90_before" type="number" inputmode="decimal" value="0">
    </label>
    <label>Extra straight AFTER 90 (in)
      <input id="s90_after" type="number" inputmode="decimal" value="0">
    </label>
    <label>Valve type
      <select id="s90_vtype">
        <option value="S">Standard</option>
        <option value="I">Inline</option>
      </select>
    </label>
  </div>

  <button class="btn" id="addBtn">Add item</button>
  <button class="btn secondary" id="clearBtn" type="button">Clear list</button>

  <div class="items" id="items"></div>
</fieldset>

<button class="btn" id="computeBtn">Compute + Draw</button>
<button class="btn secondary" id="downloadBtn" disabled>Download PNG</button>

<fieldset>
  <legend>Output (quick)</legend>
  <div id="summary" class="out"></div>
</fieldset>

<fieldset>
  <legend>Drawings</legend>
  <canvas id="sheet" width="1000" height="1700"></canvas>
  <div class="small">Sheet shows: Plan (X–Y), Elevation (X–Z), and formatted rigging directions.</div>
</fieldset>

<script>
/* --------- Constants (match your Python) --------- */
const PIPE_DIAM_IN = 24.0;
const PIPE_R_IN = PIPE_DIAM_IN / 2.0;
const W_PER_IN_DEFAULT = 8.2;

const W_EL90=475.0, S_EL90=36.0, R_EL90=(2*S_EL90)/Math.PI;
const W_EL45=240.0, S_EL45=15.0;

const W_COUP=115.0;

const W_VALVE_BODY=451.0, L_VALVE_STD=12.0;
const W_VALVE_INLINE=631.0, L_VALVE_INLINE=12.0;

const W_TEE_BODY=477.0, L_TEE=20.0;

const DEFAULT_PICK_SPACING=72.0;
const DEFAULT_BASKET_SPREAD=12.0;

/* --------- Colors --------- */
const COLORS = {
  // axes
  axisX: '#d12222',  // red
  axisY: '#2a9d2a',  // green
  axisZ: '#1f6feb',  // blue
  // fittings
  P: '#666666', // pipe (gray)
  E: '#2aa198', // 90 elbow (teal)
  F: '#2aa198', // 45 elbow (teal)
  V: '#ff9100', // valve regular (orange)
  I: '#ff9100', // valve inline (orange)
  C: '#8e44ad', // coupling (purple)
  T: '#d33682', // tee (magenta)
  W: '#d33682', // tee with valve
  G: '#2aa198', // single 90 with valve
  X: '#8d6e63', // custom per-inch (brown)
  Y: '#8d6e63', // custom fixed
  // picks
  pickLeft: '#ffd60a',   // yellow
  pickRight: '#32cd32',  // lime green
  pipeBand: 'rgba(100,100,100,0.18)', // thick band "depth"
  centerline: '#000000'
};

/* --------- Helpers --------- */
const ORIENTS = {
  A: [ 1, 0, 0], B: [-1, 0, 0],
  C: [ 0, 1, 0], D: [ 0,-1, 0],
  E: [ 0, 0, 1], F: [ 0, 0,-1],
};
function roundToQuarter(x){ return Math.round(x*4)/4; }
function fmtFtIn(x){
  const v=roundToQuarter(x);
  const ft=Math.floor(v/12);
  let rem=v-ft*12; if(Math.abs(rem-12)<1e-9){ rem=0; }
  const whole=Math.floor(rem); const frac=Math.round((rem-whole)*100)/100;
  const map={0.00:"",0.25:"-1/4",0.50:"-1/2",0.75:"-3/4"};
  const tag=map.hasOwnProperty(frac)?map[frac]:null;
  const inch = tag!==null? `${whole}${tag}"` : `${rem.toFixed(2)}"`;
  return ft? `${ft}' ${inch}` : inch;
}
function roundToEighth(x){ return Math.round(x*8)/8; }
function fmtEighthIn(x){
  const v=roundToEighth(x);
  const whole=Math.floor(v);
  const frac=v-whole;
  const fr={0.0:"",0.125:" 1/8",0.25:" 1/4",0.375:" 3/8",0.5:" 1/2",0.625:" 5/8",0.75:" 3/4",0.875:" 7/8"};
  if(fr.hasOwnProperty(frac)){
    if(whole) return `${whole}${fr[frac]}"`;
    return fr[frac]? `${fr[frac].trim()}"` : `0"`;
  }
  return `${v.toFixed(3)}"`;
}
function rollAngleDegForY(y_cg, R=PIPE_R_IN){
  const y=Math.max(-R, Math.min(R, y_cg));
  return R>0? (Math.asin(y/R)*180/Math.PI) : 0;
}
// elbow centroid magnitude (not used directly here, kept for parity)
function elbowCentroidRho(R){ return R*(Math.sin(Math.PI/4)/(Math.PI/4)); }

/* --------- State --------- */
let items = [];      // [{name, length, weight, xcg_local, tCode}]
let segments = [];   // [{tCode, start:[x,y,z], end:[x,y,z]}] in 3D
let marks = [];      // label marks [idx,x,y,z]
let xCursor = 0;     // for span

/* --------- UI wiring --------- */
const el = id=>document.getElementById(id);
const pickModeEl = el('pickMode');
const pickSpacingEl = el('pickSpacing');
const basketRow = el('basketRow');
const basketSpreadEl = el('basketSpread');
const rollThreshEl = el('rollThresh');
const itemTypeEl = el('itemType');
const orientEl = el('orient');
const lenRow = el('lenRow');
const wpiEl = el('wpi');
const wpiLabel = el('wpiLabel');
const lenInEl = el('lenIn');
const fixedRow = el('fixedRow');
const fixedWEl = el('fixedW');
const fixedLEl = el('fixedL');
const single90Row = el('single90Row');
const s90_beforeEl = el('s90_before');
const s90_afterEl = el('s90_after');
const s90_vtypeEl = el('s90_vtype');
const itemsDiv = el('items');
const summaryDiv = el('summary');
const sheet = el('sheet');
const ctx = sheet.getContext('2d');

pickModeEl.addEventListener('change', ()=>{
  basketRow.style.display = pickModeEl.value==='4' ? 'grid' : 'none';
});
itemTypeEl.addEventListener('change', updateDetailRows);
function updateDetailRows(){
  const t=itemTypeEl.value;
  lenRow.style.display='none'; fixedRow.style.display='none'; single90Row.style.display='none';
  if(t==='P'||t==='X'){ lenRow.style.display='grid'; wpiLabel.style.display='block'; }
  if(t==='Y'){ fixedRow.style.display='grid'; }
  if(t==='G'){ single90Row.style.display='grid'; }
  if(t!=='X') wpiEl.value=W_PER_IN_DEFAULT;
}
updateDetailRows();

function addItemSummary(text){
  const div=document.createElement('div'); div.className='item'; div.textContent=text;
  itemsDiv.appendChild(div);
}
function resetAll(){
  items=[]; segments=[]; marks=[]; xCursor=0; itemsDiv.innerHTML=''; summaryDiv.textContent=''; ctx.clearRect(0,0,sheet.width,sheet.height);
}
el('clearBtn').addEventListener('click', (e)=>{ e.preventDefault(); resetAll(); });

/* --------- Geometry helpers --------- */
function getCurrentEnd(){
  if(segments.length===0) return [0,0,0];
  const s=segments[segments.length-1];
  return s.end.slice();
}
function pushSegment(tCode, dir, L, labelIdx){
  const start = getCurrentEnd();
  const end = [ start[0]+dir[0]*L, start[1]+dir[1]*L, start[2]+dir[2]*L ];
  segments.push({tCode, start, end});
  // label at mid
  const mid=[ (start[0]+end[0])/2, (start[1]+end[1])/2, (start[2]+end[2])/2 ];
  marks.push([labelIdx, mid[0], mid[1], mid[2]]);
}

/* --------- Add items --------- */
function addItem(){
  const t=itemTypeEl.value;
  const idx = items.length+1;
  const [dx,dy,dz] = ORIENTS[orientEl.value] || [1,0,0];

  function placeLinear(name, L, W, xcgLocal, tCode){
    L=Math.max(0, +L);
    const Lx=L*Math.abs(dx);
    if(xcgLocal==null) xcgLocal=L/2;
    items.push({name, length:Lx, weight:W, xcg_local:(Math.abs(dx)>0? xcgLocal:0), tCode});
    pushSegment(tCode, [dx,dy,dz], L, idx);
    xCursor += Lx;
  }

  if(t==='P'){
    const L=+lenInEl.value||0, wpi=+wpiEl.value||W_PER_IN_DEFAULT;
    const W=wpi*L;
    placeLinear('24" pipe (per-inch)', L, W, null, 'P');
    addItemSummary(`${idx}. Pipe ${L.toFixed(1)} in @ ${wpi} lb/in  → ${W.toFixed(1)} lb`);

  }else if(t==='X'){
    const L=+lenInEl.value||0, wpi=+wpiEl.value||W_PER_IN_DEFAULT;
    const W=wpi*L;
    placeLinear('Custom per-inch', L, W, null, 'X');
    addItemSummary(`${idx}. Custom per-inch ${L.toFixed(1)} in @ ${wpi} → ${W.toFixed(1)} lb`);

  }else if(t==='Y'){
    const W=+fixedWEl.value||0, L=+fixedLEl.value||0;
    placeLinear('Custom fixed', L, W, null, 'Y');
    addItemSummary(`${idx}. Custom fixed ${W.toFixed(1)} lb, eff L=${L.toFixed(1)} in`);

  }else if(t==='V'){
    const L=L_VALVE_STD, W=W_VALVE_BODY + W_COUP;
    const xcgLocal=(W_VALVE_BODY*(L/2) + W_COUP*0)/W;
    placeLinear('24" valve (regular)', L, W, xcgLocal, 'V');
    addItemSummary(`${idx}. Valve (regular) L=${L} in, W=${W.toFixed(1)} lb`);

  }else if(t==='I'){
    const L=L_VALVE_INLINE, W=W_VALVE_INLINE;
    placeLinear('24" valve (inline)', L, W, L/2, 'I');
    addItemSummary(`${idx}. Valve (inline) L=${L} in, W=${W.toFixed(1)} lb`);

  }else if(t==='C'){
    // weight-only, no length; draw a tiny “stub” just to show a mark
    items.push({name:'24" coupling', length:0, weight:W_COUP, xcg_local:0, tCode:'C'});
    pushSegment('C', [dx,dy,dz], 1, idx); // 1 in visual stub
    addItemSummary(`${idx}. Coupling W=${W_COUP.toFixed(1)} lb`);

  }else if(t==='E'){
    const L=S_EL90, W=W_EL90+W_COUP;
    const xcgLocal=(W_EL90*(L/2)+W_COUP*0)/W;
    placeLinear('24" 90° elbow', L, W, xcgLocal, 'E');
    addItemSummary(`${idx}. 90° elbow L=${L} in, W=${W.toFixed(1)} lb`);

  }else if(t==='F'){
    const L=S_EL45, W=W_EL45+W_COUP;
    const xcgLocal=(W_EL45*(L/2)+W_COUP*0)/W;
    placeLinear('24" 45° elbow', L, W, xcgLocal, 'F');
    addItemSummary(`${idx}. 45° elbow L=${L} in, W=${W.toFixed(1)} lb`);

  }else if(t==='T'){
    const L=L_TEE, W=W_TEE_BODY+W_COUP;
    const xcgLocal=(W_TEE_BODY*(L/2)+W_COUP*0)/W;
    placeLinear('24" tee (plain)', L, W, xcgLocal, 'T');
    addItemSummary(`${idx}. Tee (plain) L=${L} in, W=${W.toFixed(1)} lb`);

  }else if(t==='W'){
    const L=L_TEE;
    const parts=[
      [W_TEE_BODY, L/2, 0],
      [W_VALVE_BODY, L/2, L_VALVE_STD/2],
      [W_COUP, 0, 0],
      [W_COUP, L/2, 0],
    ];
    const W = parts.reduce((a,p)=>a+p[0],0);
    const xcgLocal = parts.reduce((a,p)=>a+p[0]*p[1],0)/W;
    placeLinear('24" tee with valve', L, W, xcgLocal, 'W');
    addItemSummary(`${idx}. Tee w/ valve L=${L} in, W=${W.toFixed(1)} lb`);

  }else if(t==='G'){
    const Ls=+s90_beforeEl.value||0, La=+s90_afterEl.value||0;
    const inline = (s90_vtypeEl.value==='I');
    // Treat as straight span equals x-span; we still draw it as one segment in chosen axis.
    // Weight computed similarly to Python assembly (simplified for web).
    const R=R_EL90;
    // Pipe before
    const W1=W_PER_IN_DEFAULT*Ls;
    // Elbow
    const W2=W_EL90;
    // Valve + coupling (if std)
    let Wv=inline? W_VALVE_INLINE : W_VALVE_BODY+W_COUP;
    // After pipe
    const Wafter=W_PER_IN_DEFAULT*La;
    const Wt=W1+W2+Wv+Wafter;
    const x_span=Math.max(Ls, Ls+R, Ls+R); // conservative like Python version
    placeLinear('Single 90 with valve', x_span, Wt, Math.min(x_span/2, Ls+R/2), 'G');
    addItemSummary(`${idx}. Single 90 + valve (Ls=${Ls} in, La=${La} in, ${inline?'inline':'std'}) → W=${Wt.toFixed(1)} lb`);
  }
}
el('addBtn').addEventListener('click', (e)=>{ e.preventDefault(); addItem(); });

/* --------- Compute + draw --------- */
el('computeBtn').addEventListener('click', ()=>{
  if(items.length===0){ alert('Add at least one item.'); return; }

  const pickMode = pickModeEl.value;
  const pickSpacing = Math.max(0, +pickSpacingEl.value || DEFAULT_PICK_SPACING);
  const basketSpread = pickMode==='4' ? Math.max(0, +basketSpreadEl.value||DEFAULT_BASKET_SPREAD) : 0;
  const rollThresh = rollThreshEl.value==='' ? null : Math.max(0, +rollThreshEl.value);

  // Totals & 1D CG along X
  const totalLength = items.reduce((a,it)=>a+it.length,0);
  const totalWeight = items.reduce((a,it)=>a+it.weight,0);
  let pos=0, tm=0;
  for(const it of items){
    const c = pos + (it.xcg_local ?? it.length/2);
    tm += it.weight*c;
    pos += it.length;
  }
  const cg_x = totalWeight>0 ? tm/totalWeight : 0;

  // Approx Y/Z CG: use segment midpoints weighted by item weight fraction
  let tw=0, yMom=0, zMom=0;
  for(let i=0;i<items.length;i++){
    const it=items[i];
    const m=marks[i] || [0,0,0,0];
    yMom += it.weight * m[2];
    zMom += it.weight * m[3];
    tw += it.weight;
  }
  const cg_y = tw>0 ? yMom/tw : 0;
  const cg_z = tw>0 ? zMom/tw : 0;

  // Picks centered on CG.x and fit inside [0, totalLength]
  let leftCenter = Math.max(0, cg_x - pickSpacing/2);
  let rightCenter = leftCenter + pickSpacing;
  if(rightCenter>totalLength){ rightCenter=totalLength; leftCenter=Math.max(0, rightCenter-pickSpacing); }

  let picksForImage, picksInfo;
  if(pickMode==='2'){
    picksForImage=[leftCenter, rightCenter];
    picksInfo={mode:'2', picks:picksForImage};
  }else{
    const s=basketSpread;
    const L1=Math.max(0, leftCenter - s/2), L2=Math.min(totalLength, leftCenter + s/2);
    const R1=Math.max(0, rightCenter - s/2), R2=Math.min(totalLength, rightCenter + s/2);
    picksForImage=[L1,L2,R1,R2];
    picksInfo={mode:'4', picks:picksForImage, basket_spread:s};
  }

  // Roll + arc
  const roll_deg = rollAngleDegForY(cg_y, PIPE_R_IN);
  const roll_side = cg_y>0? 'toward +Y' : (cg_y<0? 'toward -Y' : 'no roll needed');
  const arc_in = PIPE_R_IN * (Math.abs(roll_deg)*Math.PI/180);
  const arc_in_str = fmtEighthIn(arc_in);

  // Directions text (formatted with spacing)
  const lines=[];
  lines.push(`Total weight: ${totalWeight.toFixed(1)} lb`);
  lines.push(`Span X: ${totalLength.toFixed(2)} in (${fmtFtIn(totalLength)})`);
  lines.push(`CG: X=${cg_x.toFixed(2)} in (${fmtFtIn(cg_x)}),  Y=${cg_y.toFixed(2)} in,  Z=${cg_z.toFixed(2)} in`);
  if(pickMode==='2'){
    lines.push(`Picks: Left=${fmtFtIn(picksForImage[0])},  Right=${fmtFtIn(picksForImage[1])}  (spacing ${fmtFtIn(pickSpacing)})`);
  }else{
    const [L1,L2,R1,R2]=picksForImage;
    lines.push(`Baskets (4 contacts):`);
    lines.push(`  Left:  L-=${fmtFtIn(L1)}, L+=${fmtFtIn(L2)}   (spread ${fmtFtIn(basketSpread)})`);
    lines.push(`  Right: R-=${fmtFtIn(R1)}, R+=${fmtFtIn(R2)}`);
  }
  lines.push(`Roll chokers: ~${roll_deg.toFixed(1)}° ${roll_side}`);
  lines.push(`Roll arc along circumference per choker: ${arc_in_str}`);
  if(rollThresh!==null) lines.push(`No-roll torque threshold (ft-lb): ${rollThresh.toFixed(0)} (visual check)`);
  lines.push(`Notes: Couplings are weight-only at LEFT/start faces unless noted. Inline valves are balanced.`);

  drawSheet(picksInfo, lines);

  // Quick summary panel
  let s="--- Summary ---\n";
  items.forEach((it,i)=>{ s += `${(i+1).toString().padStart(2,' ')}. ${it.name} | length=${it.length.toFixed(2)} in | weight=${it.weight.toFixed(1)} lb\n`; });
  s += `\nSpan X: ${totalLength.toFixed(2)} in (${fmtFtIn(totalLength)})\n`;
  s += `Total weight: ${totalWeight.toFixed(1)} lb\n`;
  s += `CG: X=${cg_x.toFixed(2)} in (${fmtFtIn(cg_x)}), Y=${cg_y.toFixed(2)} in, Z=${cg_z.toFixed(2)} in\n`;
  if(pickMode==='2'){ s += `Picks: L=${fmtFtIn(picksForImage[0])}, R=${fmtFtIn(picksForImage[1])}\n`; }
  else{
    const [L1,L2,R1,R2]=picksForImage;
    s += `Contacts: L-=${fmtFtIn(L1)}, L+=${fmtFtIn(L2)}, R-=${fmtFtIn(R1)}, R+=${fmtFtIn(R2)}\n`;
  }
  s += `Roll ~ ${roll_deg.toFixed(1)}° ${roll_side}\n`;
  s += `Roll arc along circumference per choker ~ ${arc_in_str}\n`;
  summaryDiv.textContent = s;

  el('downloadBtn').disabled=false;
});

el('downloadBtn').addEventListener('click', ()=>{
  const a=document.createElement('a');
  const ts = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
  a.download = `${ts}_rigging.png`;
  a.href = sheet.toDataURL('image/png');
  a.click();
});

/* --------- Drawing --------- */
function drawSheet(picksInfo, lines){
  const W=sheet.width, H=sheet.height;
  const pad=28;
  const secH = Math.floor((H - pad*5)/3);
  const planRect = {x:pad, y:pad, w:W-2*pad, h:secH};
  const elevRect = {x:pad, y:pad*2+secH, w:W-2*pad, h:secH};
  const textRect = {x:pad, y:pad*3+secH*2, w:W-2*pad, h:secH+pad};

  // clear
  ctx.fillStyle='#fff'; ctx.fillRect(0,0,W,H);

  // Build vertices from segments
  const verts=[[0,0,0]];
  for(const s of segments){
    verts.push(s.end.slice());
  }
  const px=verts.map(v=>v[0]), py=verts.map(v=>v[1]), pz=verts.map(v=>v[2]);

  drawProjection(planRect, px, py, 'Plan (X–Y)', picksInfo, 'XY');
  drawProjection(elevRect, px, pz, 'Elevation (X–Z)', picksInfo, 'XZ');

  drawTextPanel(lines, textRect);
}

// Map and draw per projection with thickness & colors
function drawProjection(rect, px, py, title, picksInfo, plane){
  // bounds
  const minX=Math.min(...px, 0), maxX=Math.max(...px, 1);
  const minY=Math.min(...py, -1), maxY=Math.max(...py, 1);

  const pad=46;
  const sx = (rect.w - pad*2) / ((maxX-minX) || 1);
  const sy = (rect.h - pad*2) / ((maxY-minY) || 1);
  const s = Math.min(sx, sy);
  const mapX = x=> rect.x + pad + (x-minX)*s;
  const mapY = y=> rect.y + rect.h - pad - (y-minY)*s;

  // Title
  ctx.fillStyle='#000'; ctx.font='18px system-ui';
  ctx.fillText(title, rect.x, rect.y-8);

  // Axes (X red, Y/Z green/blue line at zero)
  ctx.lineWidth=2;
  // X axis line at Y=0
  ctx.strokeStyle=COLORS.axisX;
  ctx.beginPath(); ctx.moveTo(mapX(minX), mapY(0)); ctx.lineTo(mapX(maxX), mapY(0)); ctx.stroke();
  // vertical zero line (x=0) colored by second axis
  ctx.strokeStyle = (plane==='XY')? COLORS.axisY : COLORS.axisZ;
  const x0=mapX(0);
  ctx.beginPath(); ctx.moveTo(x0, mapY(minY)); ctx.lineTo(x0, mapY(maxY)); ctx.stroke();

  // Pipe "depth": draw a thick band for each segment first
  const thickness = Math.min(28, Math.max(6, s * PIPE_DIAM_IN * 0.6)); // px
  ctx.lineCap='round';

  // Draw segments as bands (background)
  for(const seg of segments){
    const sx0=mapX(seg.start[0]), sy0=mapY( plane==='XY'? seg.start[1] : seg.start[2] );
    const sx1=mapX(seg.end[0]),   sy1=mapY( plane==='XY'? seg.end[1]   : seg.end[2] );
    ctx.strokeStyle = COLORS.pipeBand;
    ctx.lineWidth = thickness;
    ctx.beginPath(); ctx.moveTo(sx0, sy0); ctx.lineTo(sx1, sy1); ctx.stroke();
  }

  // Overlay centerline per segment in fitting color
  for(const seg of segments){
    const sx0=mapX(seg.start[0]), sy0=mapY( plane==='XY'? seg.start[1] : seg.start[2] );
    const sx1=mapX(seg.end[0]),   sy1=mapY( plane==='XY'? seg.end[1]   : seg.end[2] );
    ctx.strokeStyle = COLORS[seg.tCode] || COLORS.centerline;
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(sx0, sy0); ctx.lineTo(sx1, sy1); ctx.stroke();
  }

  // Labels at marks
  ctx.fillStyle='#000'; ctx.font='13px system-ui';
  for(const m of marks){
    const x=m[1], y=(plane==='XY'? m[2] : m[3]);
    ctx.fillText(String(m[0]), mapX(x)+4, mapY(y)-4);
  }

  // Pick markers with arrowheads + color fill
  if(picksInfo.mode==='2'){
    const [xl, xr]=picksInfo.picks;
    drawPickMarker(mapX(xl), mapY(0), COLORS.pickLeft, 'Pick L');
    drawPickMarker(mapX(xr), mapY(0), COLORS.pickRight, 'Pick R');
  }else{
    const [L1,L2,R1,R2]=picksInfo.picks;
    drawPickMarker(mapX(L1), mapY(0), COLORS.pickLeft, 'L-');
    drawPickMarker(mapX(L2), mapY(0), COLORS.pickLeft, 'L+');
    drawPickMarker(mapX(R1), mapY(0), COLORS.pickRight, 'R-');
    drawPickMarker(mapX(R2), mapY(0), COLORS.pickRight, 'R+');
  }

  // Border
  ctx.strokeStyle='#cfd4d9'; ctx.lineWidth=1;
  ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
}

function drawPickMarker(x, y, color, label){
  // arrow + dot + label
  ctx.strokeStyle=color; ctx.fillStyle=color;
  // arrow
  ctx.beginPath();
  ctx.moveTo(x, y-14); ctx.lineTo(x, y-2); ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x, y-2); ctx.lineTo(x-6, y-8);
  ctx.moveTo(x, y-2); ctx.lineTo(x+6, y-8);
  ctx.stroke();
  // dot
  ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI*2); ctx.fill();
  // label
  ctx.fillStyle='#000'; ctx.font='12px system-ui';
  ctx.fillText(label, x+6, y-16);
}

function drawTextPanel(lines, rect){
  // Panel box
  ctx.strokeStyle='#cfd4d9'; ctx.lineWidth=1;
  ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);

  // Header
  ctx.fillStyle='#000';
  ctx.font='18px system-ui';
  ctx.fillText('Rigging directions', rect.x+10, rect.y+26);

  // Body text with generous line height and wrapping
  ctx.font='14px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
  const lh=22, pad=12, maxW=rect.w-2*pad;
  let y=rect.y+26+10;

  for(let i=0;i<lines.length;i++){
    const t = lines[i];
    y = drawWrappedText(t, rect.x+pad, y, maxW, lh);
    y += 6;  // extra spacing between lines
    // soft divider after key blocks
    if(i===2 || i===4){ ctx.strokeStyle='#eee'; ctx.beginPath(); ctx.moveTo(rect.x+pad, y); ctx.lineTo(rect.x+rect.w-pad, y); ctx.stroke(); y+=6; }
  }
}

function drawWrappedText(text, x, y, maxWidth, lh){
  const words=text.split(' ');
  let line='';
  for(const w of words){
    const test=line? line+' '+w : w;
    if(ctx.measureText(test).width > maxWidth){
      ctx.fillText(line, x, y);
      line=w; y+=lh;
    }else{
      line=test;
    }
  }
  if(line){ ctx.fillText(line, x, y); }
  return y;
}

/* --------- Start clean --------- */
document.getElementById('addBtn').focus();
</script>
</body>
</html>
