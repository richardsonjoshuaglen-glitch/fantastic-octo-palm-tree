<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Rigging CG Helper — 2-Pick with Joint Selection</title>
<style>
  :root{
    --bg:#ffffff; --ink:#111; --panel:#f6f8fa; --border:#e9ecef; --accent:#0d6efd;
    --pickL:#ffd60a; --pickR:#32cd32; --roll:#5bc0ff;
  }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:16px; color:var(--ink); background:var(--bg); }
  h1 { font-size:20px; margin:0 0 10px; display:flex; align-items:center; gap:10px;}
  .badge{display:inline-block; padding:2px 8px; border-radius:999px; background:#d1e7dd; color:#0f5132; font-weight:700; font-size:12px;}
  fieldset { border:1px solid #ccc; border-radius:10px; margin:10px 0; padding:10px 12px; }
  legend { padding:0 6px; font-weight:600; }
  label { display:block; margin:6px 0 2px; font-size:14px; }
  select, input[type="number"] { width:100%; font-size:16px; padding:10px 12px; box-sizing:border-box; border-radius:8px; border:1px solid #cfd4d9; }
  .row { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
  .row3{ display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px; }
  .btn { display:inline-block; padding:10px 12px; margin:8px 6px 0 0; border-radius:10px; background:var(--accent); color:#fff; border:none; font-size:16px; cursor:pointer;}
  .btn.secondary{ background:#6c757d; }
  .items{ margin-top:6px;}
  .item{ padding:8px; border:1px dashed #999; border-radius:8px; margin-bottom:8px; font-size:14px;}
  .out{ background:var(--panel); padding:12px; border-radius:10px; border:1px solid var(--border); line-height:1.5; font-size:15px;}
  .out h3{ margin:6px 0; font-size:16px;}
  .pill{ display:inline-block; padding:2px 8px; border-radius:999px; font-weight:600; font-size:12px; color:#000;}
  .pill.left{ background:var(--pickL); } .pill.right{ background:var(--pickR); } .pill.roll{ background:var(--roll); }
  .muted{ color:#555; font-size:12px; }
  #sheet{ width:100%; max-width:1000px; background:#fff; border:1px solid #ddd; border-radius:8px; display:block;}
  #debug{ margin-top:6px; font-size:12px; color:#b00020; white-space:pre-wrap; border:1px dashed #ddd; padding:6px; border-radius:6px;}
  .smallcap{font-variant: all-small-caps; letter-spacing:.03em; color:#333;}
  .joint-pill{display:inline-block; padding:1px 6px; border-radius:999px; border:1px solid #ddd; background:#fff; margin-left:6px; font-size:12px; color:#333;}
</style>
</head>
<body>
<h1>Rigging CG Helper — 2-Pick with Joint Selection <span class="badge" id="badge">JS not ready</span></h1>

<!-- OUTPUT FIRST -->
<fieldset>
  <legend>Output (quick)</legend>
  <div id="summary" class="out">Add items and click “Compute + Draw”.</div>
  <div class="muted">Legend: <span class="pill left">Left pick</span> <span class="pill right">Right pick</span> · “Left Edge” = minimum coordinate on the axis used for that pick.</div>
</fieldset>

<!-- PICK SETUP -->
<fieldset>
  <legend>Pick setup (2 picks)</legend>
  <div class="row">
    <label>Pick mode
      <select id="pickMode">
        <option value="AUTO" selected>Auto (about CG, spacing fluid)</option>
        <option value="JOINTS">By joints (select two numbers after compute)</option>
      </select>
    </label>
    <label>Nominal pick spacing (in) <span class="smallcap">(advisory)</span>
      <input id="pickSpacing" type="number" inputmode="decimal" value="72">
    </label>
  </div>

  <div class="row">
    <label>Left pick axis
      <select id="axisL">
        <option value="AUTO" selected>Auto (largest span)</option>
        <option value="X">X — Left → Right</option>
        <option value="Y">Y — Toward / Away</option>
        <option value="Z">Z — Up / Down</option>
      </select>
    </label>
    <label>Right pick axis
      <select id="axisR">
        <option value="AUTO" selected>Auto (largest span)</option>
        <option value="X">X — Left → Right</option>
        <option value="Y">Y — Toward / Away</option>
        <option value="Z">Z — Up / Down</option>
      </select>
    </label>
  </div>

  <div class="row">
    <label>Coupling avoidance (in) — only for AUTO mode
      <input id="couplingClear" type="number" inputmode="decimal" value="2">
    </label>
    <label>Pipe OD (for roll info; in)
      <input id="pipeOD" type="number" inputmode="decimal" value="24">
    </label>
  </div>

  <!-- Joints mode controls (populated after Compute) -->
  <div id="jointsBox" style="display:none; margin-top:6px;">
    <div class="muted" id="jointCountNote">Joints will appear here after you Compute.</div>
    <div class="row" style="margin-top:8px;">
      <label>Left pick joint
        <select id="jointL"></select>
      </label>
      <label>Right pick joint
        <select id="jointR"></select>
      </label>
    </div>
    <button class="btn" id="applyJointPicks" type="button">Apply joint picks</button>
  </div>
  <div class="muted">XYZ: X+ Left→Right · X− Right→Left · Y+ Toward · Y− Away · Z+ Up · Z− Down</div>
</fieldset>

<!-- ADD ITEMS -->
<fieldset>
  <legend>Add item</legend>
  <div class="row">
    <label>Item type
      <select id="itemType">
        <option value="P">24″ pipe (per-inch)</option>
        <option value="V">24″ valve (regular)</option>
        <option value="C">24″ coupling (weight only)</option>
        <option value="E">24″ 90° elbow</option>
        <option value="F">24″ 45° elbow</option>
        <option value="T">24″ tee (plain)</option>
        <option value="W">24″ tee with valve</option>
        <option value="X">Custom per-inch</option>
        <option value="Y">Custom fixed</option>
      </select>
    </label>
    <label>Orientation (axis + layman direction)
      <select id="orient">
        <option value="A" selected>A — X+ (Left → Right)</option>
        <option value="B">B — X− (Right → Left)</option>
        <option value="C">C — Y+ (Toward)</option>
        <option value="D">D — Y− (Away)</option>
        <option value="E">E — Z+ (Up)</option>
        <option value="F">F — Z− (Down)</option>
      </select>
    </label>
  </div>
  <div class="row" id="lenRow">
    <label>Length (in)
      <input id="lenIn" type="number" inputmode="decimal" value="60">
    </label>
    <label id="wpiLabel">Weight per inch (lb/in)
      <input id="wpi" type="number" inputmode="decimal" value="8.2">
    </label>
  </div>
  <div class="row" id="fixedRow" style="display:none">
    <label>Total weight (lb)
      <input id="fixedW" type="number" inputmode="decimal" value="0">
    </label>
    <label>Effective length along chosen axis (in)
      <input id="fixedL" type="number" inputmode="decimal" value="0">
    </label>
  </div>

  <button class="btn" id="addBtn" type="button">Add item</button>
  <button class="btn secondary" id="clearBtn" type="button">Clear list</button>

  <div class="items" id="items"></div>
  <div id="debug">debug: ready</div>
</fieldset>

<button class="btn" id="computeBtn" type="button">Compute + Draw</button>
<button class="btn secondary" id="downloadBtn" type="button" disabled>Download PNG</button>

<!-- DRAWINGS -->
<fieldset>
  <legend>Drawings</legend>
  <canvas id="sheet"></canvas>
  <div class="muted">Plan (X–Y) and Elevation (X–Z). Joints are labeled J0…Jn at every connection/end. Each pick is shown on its own axis zero line.</div>
</fieldset>

<script>
/* ---------- setup ---------- */
(function(){ const b=document.getElementById('badge'); if(b) b.textContent='Ready'; })();
function el(id){ return document.getElementById(id); }
function setupCanvas(canvas, cssW, cssH){
  cssW=cssW||1000; cssH=cssH||1000;
  const dpr=window.devicePixelRatio||1;
  canvas.style.width=cssW+'px'; canvas.style.height=cssH+'px';
  canvas.width=Math.floor(cssW*dpr); canvas.height=Math.floor(cssH*dpr);
  const ctx=canvas.getContext('2d'); ctx.setTransform(dpr,0,0,dpr,0,0); ctx.textBaseline='top'; return ctx;
}
const sheet=el('sheet'); let ctx=setupCanvas(sheet);

/* ---------- constants ---------- */
const W_PER_IN_DEFAULT=8.2;
const W_EL90=475.0, S_EL90=36.0;
const W_EL45=240.0, S_EL45=15.0;
const W_COUP=115.0;
const W_VALVE_BODY=451.0, L_VALVE_STD=12.0;
const W_TEE_BODY=477.0, L_TEE=20.0;

const COLORS={
  axisX:'#d12222', axisY:'#2a9d2a', axisZ:'#1f6feb',
  P:'#666666', E:'#2aa198', F:'#2aa198', V:'#ff9100', C:'#8e44ad', T:'#d33682', W:'#d33682', X:'#8d6e63', Y:'#8d6e63',
  pickLeft:getComputedStyle(document.documentElement).getPropertyValue('--pickL')||'#ffd60a',
  pickRight:getComputedStyle(document.documentElement).getPropertyValue('--pickR')||'#32cd32',
  pipeBand:'rgba(100,100,100,0.18)', centerline:'#000'
};
const ORIENTS={ A:[ 1,0,0], B:[-1,0,0], C:[ 0,1,0], D:[ 0,-1,0], E:[ 0,0,1], F:[ 0,0,-1] };

/* ---------- helpers ---------- */
function r4(x){ return Math.round(x*4)/4; }
function r8(x){ return Math.round(x*8)/8; }
function fmtFtIn(x){
  const v=r4(x), ft=Math.floor(v/12), rem=v-ft*12;
  const whole=Math.floor(rem), frac=Math.round((rem-whole)*100)/100;
  const map={"0":"", "0.25":"-1/4", "0.5":"-1/2", "0.75":"-3/4"};
  const tag=(map.hasOwnProperty(String(frac))?map[String(frac)]:null);
  const inch=(tag!==null)? (whole+tag+'"') : (rem.toFixed(2)+'"');
  return ft? (ft+"' "+inch) : inch;
}
function addV(a,b){ return [a[0]+b[0],a[1]+b[1],a[2]+b[2]]; }
function mulV(a,k){ return [a[0]*k,a[1]*k,a[2]*k]; }

/* ---------- state ---------- */
let items=[], segments=[], marks=[], joints=[]; // joints = array of vertex points in order

/* ---------- UI ---------- */
window.addEventListener('load', ()=>{
  el('itemType').addEventListener('change', updateDetailRows);
  el('addBtn').addEventListener('click', addItem);
  el('clearBtn').addEventListener('click', resetAll);
  el('computeBtn').addEventListener('click', computeAndDraw);
  el('applyJointPicks').addEventListener('click', applyJointSelection);
  el('pickMode').addEventListener('change', ()=>{ el('jointsBox').style.display = (el('pickMode').value==='JOINTS' ? 'block' : 'none'); });
  el('downloadBtn').addEventListener('click', ()=>{
    const a=document.createElement('a'); const ts=new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
    a.download=ts+'_rigging.png'; a.href=sheet.toDataURL('image/png'); a.click();
  });
  updateDetailRows();
});

function updateDetailRows(){
  const t=el('itemType').value;
  el('lenRow').style.display = (t==='P'||t==='X')?'grid':'none';
  el('wpiLabel').style.display = (t==='P'||t==='X')?'block':'none';
  el('fixedRow').style.display = (t==='Y')?'grid':'none';
}

/* ---------- geometry building ---------- */
function getEnd(){ return segments.length===0?[0,0,0]:segments[segments.length-1].end.slice(); }
function pushSegment(tCode, dir, L, labelIdx){
  const s=getEnd(), e=[s[0]+dir[0]*L, s[1]+dir[1]*L, s[2]+dir[2]*L];
  segments.push({tCode, start:s, end:e});
  const mid=[(s[0]+e[0])/2,(s[1]+e[1])/2,(s[2]+e[2])/2];
  marks.push([labelIdx, mid[0], mid[1], mid[2]]);
}
function addItemRow(idx, txt){
  const d=document.createElement('div'); d.className='item';
  d.innerHTML = (idx+'. '+txt) + ' <span class="joint-pill">ends at J'+idx+'</span>';
  el('items').appendChild(d);
}

/* Items */
function addItem(){
  try{
    const t=el('itemType').value, idx=items.length+1, d=ORIENTS[el('orient').value]||[1,0,0];

    function placeLinear(name, L, W, xcgLocal, tCode){
      L=Math.max(0, Number(L)||0);
      if(xcgLocal==null) xcgLocal=L/2;
      items.push({name, length:L, weight:W, xcg_local:xcgLocal, tCode});
      pushSegment(tCode, d, L, idx);
    }

    if(t==='P'){
      const L=Number(el('lenIn').value)||0, wpi=Number(el('wpi').value)||W_PER_IN_DEFAULT;
      const W=wpi*L; placeLinear('24" pipe', L, W, null, 'P');
      addItemRow(idx, `Pipe ${L.toFixed(1)} in @ ${wpi} → ${W.toFixed(1)} lb`);

    }else if(t==='X'){
      const Lx=Number(el('lenIn').value)||0, wpiX=Number(el('wpi').value)||W_PER_IN_DEFAULT;
      const WX=wpiX*Lx; placeLinear('Custom per-inch', Lx, WX, null, 'X');
      addItemRow(idx, `Custom per-inch ${Lx.toFixed(1)} in @ ${wpiX} → ${WX.toFixed(1)} lb`);

    }else if(t==='Y'){
      const WY=Number(el('fixedW').value)||0, LY=Number(el('fixedL').value)||0;
      placeLinear('Custom fixed', LY, WY, null, 'Y');
      addItemRow(idx, `Custom fixed ${WY.toFixed(1)} lb, eff L=${LY.toFixed(1)} in`);

    }else if(t==='V'){
      const LV=L_VALVE_STD, WV=W_VALVE_BODY;
      placeLinear('Valve (regular)', LV, WV, LV/2, 'V');
      addItemRow(idx, `Valve reg L=${LV} in, W=${WV.toFixed(1)} lb`);

    }else if(t==='C'){
      items.push({name:'Coupling', length:0, weight:W_COUP, xcg_local:0, tCode:'C'});
      pushSegment('C', d, 1, idx); // 1" stub, for visibility
      addItemRow(idx, `Coupling W=${W_COUP.toFixed(1)} lb`);

    }else if(t==='E'){
      placeLinear('90° elbow', S_EL90, W_EL90, S_EL90/2, 'E');
      addItemRow(idx, `90° elbow L=${S_EL90} in, W=${W_EL90.toFixed(1)} lb`);

    }else if(t==='F'){
      placeLinear('45° elbow', S_EL45, W_EL45, S_EL45/2, 'F');
      addItemRow(idx, `45° elbow L=${S_EL45} in, W=${W_EL45.toFixed(1)} lb`);

    }else if(t==='T'){
      placeLinear('Tee (plain)', L_TEE, W_TEE_BODY, L_TEE/2, 'T');
      addItemRow(idx, `Tee L=${L_TEE} in, W=${W_TEE_BODY.toFixed(1)} lb`);

    }else if(t==='W'){
      const LW=L_TEE, WT=W_TEE_BODY+W_VALVE_BODY;
      const xcg=(W_TEE_BODY*(LW/2)+W_VALVE_BODY*(LW/2))/WT;
      placeLinear('Tee + valve', LW, WT, xcg, 'W');
      addItemRow(idx, `Tee + valve L=${LW} in, W=${WT.toFixed(1)} lb`);
    }

    el('debug').textContent='debug: items='+items.length;
  }catch(e){
    el('debug').textContent='debug: addItem error: '+e;
  }
}

function resetAll(){
  items=[]; segments=[]; marks=[]; joints=[];
  el('items').innerHTML='';
  el('summary').innerHTML='Add items and click “Compute + Draw”.';
  ctx.clearRect(0,0,sheet.width,sheet.height);
  el('debug').textContent='debug: reset';
  el('jointsBox').style.display='none';
}

/* ---------- CG with couplings at joints (weight only) ---------- */
function computeCG(){
  let totalW=0, sum=[0,0,0];
  for(let i=0;i<items.length;i++){
    const w=items[i].weight, p=[marks[i][1],marks[i][2],marks[i][3]];
    totalW+=w; sum=addV(sum, mulV(p,w));
  }
  // auto coupling at every joint (except before first)
  for(let j=0;j<segments.length-1;j++){
    const end=segments[j].end; totalW+=W_COUP; sum=addV(sum, mulV(end, W_COUP));
  }
  return {CG: totalW? mulV(sum,1/totalW):[0,0,0], totalW};
}

/* ---------- axis + extents ---------- */
function extentAlong(axisIndex){
  const arr=[]; for(let i=0;i<segments.length;i++){ arr.push(segments[i].start[axisIndex], segments[i].end[axisIndex]); }
  const mn=Math.min.apply(null,arr), mx=Math.max.apply(null,arr);
  return {min:mn, max:mx, span:mx-mn};
}
function chooseAxis(sel){
  if(sel!=='AUTO') return sel;
  const exX=extentAlong(0), exY=extentAlong(1), exZ=extentAlong(2);
  let best='X', span=exX.span;
  if(exY.span>span){ best='Y'; span=exY.span; }
  if(exZ.span>span){ best='Z'; span=exZ.span; }
  return best;
}

/* ---------- coupling avoidance windows for AUTO only ---------- */
function couplingWindows(axisIndex, clear){
  const windows=[];
  // explicit coupling segments
  for(let i=0;i<segments.length;i++){
    const code=(items[i]||{}).tCode || segments[i].tCode;
    if(code==='C'){
      const s=segments[i].start[axisIndex], e=segments[i].end[axisIndex];
      const pos=(s+e)/2; windows.push([pos-clear, pos+clear]);
    }
  }
  // auto couplings at each joint
  for(let j=0;j<segments.length-1;j++){
    const end=segments[j].end; const pos=end[axisIndex];
    windows.push([pos-clear, pos+clear]);
  }
  windows.sort((A,B)=>A[0]-B[0]);
  const merged=[];
  for(const w of windows){
    if(!merged.length || w[0]>merged[merged.length-1][1]){
      merged.push(w.slice());
    }else{
      merged[merged.length-1][1]=Math.max(merged[merged.length-1][1], w[1]);
    }
  }
  return merged;
}
function allowed(x, windows){ for(const w of windows){ if(x>=w[0] && x<=w[1]) return false; } return true; }
function slideWithin(ext, target, windows){
  const step=0.5, maxShift=ext.span+120;
  target=Math.max(ext.min, Math.min(ext.max, target));
  if(allowed(target, windows)) return target;
  for(let k=1; k*step<=maxShift; k++){
    const a=target-k*step, b=target+k*step;
    if(a>=ext.min && allowed(a,windows)) return a;
    if(b<=ext.max && allowed(b,windows)) return b;
  }
  return Math.max(ext.min, Math.min(ext.max, target));
}

/* ---------- joints list ---------- */
function buildJoints(){
  joints=[];
  // start point
  if(segments.length===0){ return; }
  joints.push( segments[0].start.slice() );
  for(let i=0;i<segments.length;i++){
    joints.push( segments[i].end.slice() );
  }
}

/* ---------- compute & draw ---------- */
let lastPicks = null; // remember for redraw after joint selection

function computeAndDraw(){
  if(items.length===0){ alert('Add at least one item.'); return; }

  const {CG,totalW}=computeCG();
  buildJoints();

  // Populate the joints UI if in joint mode
  const jBox = el('jointsBox');
  const mode = el('pickMode').value;
  if(mode==='JOINTS'){
    jBox.style.display='block';
    const jointL=el('jointL'), jointR=el('jointR');
    jointL.innerHTML=''; jointR.innerHTML='';
    const axisNames=['X','Y','Z'];
    for(let i=0;i<joints.length;i++){
      const p=joints[i];
      const text=`J${i} — (X:${p[0].toFixed(2)}", Y:${p[1].toFixed(2)}", Z:${p[2].toFixed(2)}")`;
      const optL=document.createElement('option'); optL.value=String(i); optL.textContent=text;
      const optR=document.createElement('option'); optR.value=String(i); optR.textContent=text;
      jointL.appendChild(optL); jointR.appendChild(optR);
    }
    // helpful default: left = the joint left of CG along chosen axis, right = right of CG
    jointL.selectedIndex = 0;
    jointR.selectedIndex = Math.max(1, joints.length-1);
  }else{
    jBox.style.display='none';
  }

  // AUTO placement (advisory spacing, with coupling avoidance); JOINTS is applied separately
  const axisL = chooseAxis(el('axisL').value);
  const axisR = chooseAxis(el('axisR').value);
  const axL = (axisL==='X'?0:(axisL==='Y'?1:2));
  const axR = (axisR==='X'?0:(axisR==='Y'?1:2));
  const exL = extentAlong(axL), exR = extentAlong(axR);
  let spacing = Number(el('pickSpacing').value)||72; if(spacing<0) spacing=0;

  const targL = Math.max(exL.min, Math.min(exL.max, CG[axL] - spacing/2));
  const targR = Math.max(exR.min, Math.min(exR.max, CG[axR] + spacing/2));
  const clear = Math.max(0, Number(el('couplingClear').value)||2);
  const winL = couplingWindows(axL, clear);
  const winR = couplingWindows(axR, clear);
  const posL = slideWithin(exL, targL, winL);
  const posR = slideWithin(exR, targR, winR);

  lastPicks = { mode:'AUTO', axisL, axisR, posL, posR, CG, totalW, exL, exR };

  // roll info (FYI)
  const R=(Number(el('pipeOD').value)||24)/2;
  const y=CG[1], yclamped=Math.max(-R, Math.min(R, y));
  const rollDeg = (R>0)? (Math.asin(yclamped/R)*180/Math.PI) : 0;
  const rollSide = (y>0?'toward +Y':(y<0?'toward -Y':'no roll needed'));
  const arc = R * (Math.abs(rollDeg)*Math.PI/180);

  // Output summary (AUTO by default; JOINTS can override with button)
  const minEdgeL = exL.min, minEdgeR = exR.min;
  let html='';
  html += '<h3>Totals</h3>';
  html += '<div>Total weight: <b>'+totalW.toFixed(1)+' lb</b></div>';
  html += '<div>CG (in): X=<b>'+CG[0].toFixed(2)+'</b>, Y=<b>'+CG[1].toFixed(2)+'</b>, Z=<b>'+CG[2].toFixed(2)+'</b></div>';
  html += '<h3>Pick Points (AUTO)</h3>';
  html += '<div><span class="pill left">Left pick</span> axis <b>'+axisL+'</b>: '+fmtFtIn(posL - minEdgeL)+' from Left Edge</div>';
  html += '<div><span class="pill right">Right pick</span> axis <b>'+axisR+'</b>: '+fmtFtIn(posR - minEdgeR)+' from Left Edge</div>';
  html += '<div class="muted">Switch to “By joints” to place picks exactly at chosen joints.</div>';
  html += '<h3>Roll (info)</h3>';
  html += '<div><span class="pill roll">Roll</span> ≈ '+rollDeg.toFixed(1)+'° '+rollSide+'; circumference offset per choker ≈ '+(r8(arc)).toFixed(3).replace(/\.000$/,'')+'"</div>';
  el('summary').innerHTML = html;

  drawAll({axisL, axisR, posL, posR}, /*jointLabels*/true);
  el('downloadBtn').disabled=false;
}

/* Apply joint-based selection */
function applyJointSelection(){
  if(!joints.length){ alert('Run Compute first to build joints.'); return; }
  // Use current axis selections; picks at joint coordinates along each axis
  const axisL = (el('axisL').value==='AUTO') ? chooseAxis('AUTO') : el('axisL').value;
  const axisR = (el('axisR').value==='AUTO') ? chooseAxis('AUTO') : el('axisR').value;
  const axL = (axisL==='X'?0:(axisL==='Y'?1:2));
  const axR = (axisR==='X'?0:(axisR==='Y'?1:2));
  const exL = extentAlong(axL), exR = extentAlong(axR);

  const iL = Number(el('jointL').value);
  const iR = Number(el('jointR').value);
  if(!(iL>=0) || !(iR>=0) || iL>=joints.length || iR>=joints.length){
    alert('Choose valid joints for Left and Right.'); return;
  }
  const pL = joints[iL][axL];
  const pR = joints[iR][axR];

  // Store & redraw
  lastPicks = lastPicks || {};
  lastPicks.mode='JOINTS';
  lastPicks.axisL=axisL; lastPicks.axisR=axisR;
  lastPicks.posL=pL; lastPicks.posR=pR;
  lastPicks.exL=exL; lastPicks.exR=exR;

  // Update summary replacing AUTO block
  const CG = (lastPicks.CG) ? lastPicks.CG : computeCG().CG;
  const totalW = (lastPicks.totalW) ? lastPicks.totalW : computeCG().totalW;

  const R=(Number(el('pipeOD').value)||24)/2;
  const y=CG[1], yclamped=Math.max(-R, Math.min(R, y));
  const rollDeg = (R>0)? (Math.asin(yclamped/R)*180/Math.PI) : 0;
  const rollSide = (y>0?'toward +Y':(y<0?'toward -Y':'no roll needed'));
  const arc = R * (Math.abs(rollDeg)*Math.PI/180);

  const minEdgeL = exL.min, minEdgeR = exR.min;
  let html='';
  html += '<h3>Totals</h3>';
  html += '<div>Total weight: <b>'+totalW.toFixed(1)+' lb</b></div>';
  html += '<div>CG (in): X=<b>'+CG[0].toFixed(2)+'</b>, Y=<b>'+CG[1].toFixed(2)+'</b>, Z=<b>'+CG[2].toFixed(2)+'</b></div>';
  html += '<h3>Pick Points (By joints)</h3>';
  html += '<div><span class="pill left">Left pick</span> axis <b>'+axisL+'</b>: J'+iL+' → '+fmtFtIn(pL - minEdgeL)+' from Left Edge</div>';
  html += '<div><span class="pill right">Right pick</span> axis <b>'+axisR+'</b>: J'+iR+' → '+fmtFtIn(pR - minEdgeR)+' from Left Edge</div>';
  html += '<div class="muted">Spacing is ignored in joints mode; picks are exactly at the selected joints.</div>';
  html += '<h3>Roll (info)</h3>';
  html += '<div><span class="pill roll">Roll</span> ≈ '+rollDeg.toFixed(1)+'° '+rollSide+'; circumference offset per choker ≈ '+(r8(arc)).toFixed(3).replace(/\.000$/,'')+'"</div>';
  el('summary').innerHTML = html;

  drawAll({axisL, axisR, posL:pL, posR:pR}, /*jointLabels*/true);
}

/* ---------- drawing ---------- */
function drawAll(picks, jointLabels){
  ctx=setupCanvas(sheet, 1000, 1000);
  const W=1000,H=1000,pad=28, secH=Math.floor((H-pad*3)/2);
  const planRect={x:pad,y:pad,w:W-2*pad,h:secH};
  const elevRect={x:pad,y:pad*2+secH,w:W-2*pad,h:secH};

  ctx.fillStyle='#fff'; ctx.fillRect(0,0,W,H);

  const verts=[[0,0,0]]; for(let i=0;i<segments.length;i++){ verts.push(segments[i].end.slice()); }
  const px=verts.map(v=>v[0]), py=verts.map(v=>v[1]), pz=verts.map(v=>v[2]);

  drawProjection(planRect, px, py, 'Plan (X–Y)', picks, 'XY', jointLabels);
  drawProjection(elevRect, px, pz, 'Elevation (X–Z)', picks, 'XZ', jointLabels);
}

function drawProjection(rect, px, py, title, picks, plane, jointLabels){
  const minX=Math.min.apply(null, px.concat([0])), maxX=Math.max.apply(null, px.concat([1]));
  const minY=Math.min.apply(null, py.concat([-1])), maxY=Math.max.apply(null, py.concat([1]));

  const pad=46, sx=(rect.w-pad*2)/((maxX-minX)||1), sy=(rect.h-pad*2)/((maxY-minY)||1), s=Math.min(sx,sy);
  const mapX=x=>rect.x+pad+(x-minX)*s;
  const mapY=y=>rect.y+rect.h-pad-(y-minY)*s;

  ctx.fillStyle='#000'; ctx.font='18px system-ui'; ctx.fillText(title, rect.x, rect.y-6);

  // axes
  ctx.lineWidth=2;
  ctx.strokeStyle=COLORS.axisX; ctx.beginPath(); ctx.moveTo(mapX(minX), mapY(0)); ctx.lineTo(mapX(maxX), mapY(0)); ctx.stroke();
  ctx.strokeStyle=(plane==='XY')?COLORS.axisY:COLORS.axisZ;
  const x0=mapX(0); ctx.beginPath(); ctx.moveTo(x0, mapY(minY)); ctx.lineTo(x0, mapY(maxY)); ctx.stroke();

  // pipe band & centerlines
  const thickness=Math.min(28, Math.max(8, s*24*0.6)); ctx.lineCap='round';
  segments.forEach(seg=>{
    const sx0=mapX(seg.start[0]), sy0=mapY(plane==='XY'?seg.start[1]:seg.start[2]);
    const sx1=mapX(seg.end[0]),   sy1=mapY(plane==='XY'?seg.end[1]:seg.end[2]);
    ctx.strokeStyle=COLORS.pipeBand; ctx.lineWidth=thickness; ctx.beginPath(); ctx.moveTo(sx0,sy0); ctx.lineTo(sx1,sy1); ctx.stroke();
  });
  segments.forEach(seg=>{
    const sx0=mapX(seg.start[0]), sy0=mapY(plane==='XY'?seg.start[1]:seg.start[2]);
    const sx1=mapX(seg.end[0]),   sy1=mapY(plane==='XY'?seg.end[1]:seg.end[2]);
    ctx.strokeStyle=COLORS[seg.tCode]||COLORS.centerline; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(sx0,sy0); ctx.lineTo(sx1,sy1); ctx.stroke();
  });

  // segment number labels at middles
  ctx.fillStyle='#000'; ctx.font='13px system-ui';
  for(let m=0;m<marks.length;m++){
    const mk=marks[m]; const x=mk[1], y=(plane==='XY'?mk[2]:mk[3]);
    ctx.fillText(String(mk[0]), mapX(x)+4, mapY(y)-16);
  }

  // joint labels J0..Jn at vertices
  if(jointLabels && joints.length){
    ctx.fillStyle='#222'; ctx.font='12px system-ui';
    for(let j=0;j<joints.length; j++){
      const v=joints[j]; const vx=mapX(v[0]), vy=mapY( (plane==='XY'? v[1] : v[2]) );
      // small target + label
      ctx.beginPath(); ctx.arc(vx, vy, 3, 0, Math.PI*2); ctx.fill();
      ctx.fillText('J'+j, vx+6, vy-6);
    }
  }

  // per-pick markers on each pick’s axis zero line (for visibility)
  function drawPick(axis, value, color, label){
    let pxCoord=0, pyCoord=0;
    if(axis==='X'){ pxCoord=value; pyCoord=0; }
    else if(axis==='Y'){ pxCoord=0; pyCoord=(plane==='XY'? value:0); }
    else if(axis==='Z'){ pxCoord=0; pyCoord=(plane==='XZ'? value:0); }
    const topY=rect.y+10;
    const pillX=(label==='L')? rect.x+12 : rect.x+152;
    const pillW=(label==='L')? 140 : 150;
    const pillText=(label==='L')? ('Left pick ('+axis+')') : ('Right pick ('+axis+')');
    drawTopPill(pillX, topY-8, pillW, 20, color, pillText);
    drawLeader(pillX + pillW/2, topY+12, mapX(pxCoord), mapY(pyCoord), color);
    drawPickMarker(mapX(pxCoord), mapY(pyCoord), color, label);
  }
  drawPick(picks.axisL, picks.posL, COLORS.pickLeft, 'L');
  drawPick(picks.axisR, picks.posR, COLORS.pickRight, 'R');

  // border
  ctx.strokeStyle='#cfd4d9'; ctx.lineWidth=1; ctx.strokeRect(rect.x,rect.y,rect.w,rect.h);

  function drawTopPill(x,y,w,h,color,label){
    ctx.fillStyle=color; ctx.strokeStyle=color; const r=h/2;
    ctx.beginPath(); ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y);
    ctx.arc(x+w-r,y+r,r,-Math.PI/2,Math.PI/2);
    ctx.lineTo(x+r,y+h); ctx.arc(x+r,y+r,r,Math.PI/2,Math.PI*1.5);
    ctx.closePath(); ctx.fill(); ctx.fillStyle='#000'; ctx.font='12px system-ui'; ctx.fillText(label, x+8, y+3);
  }
  function drawLeader(x1,y1,x2,y2,color){
    ctx.strokeStyle=color; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  }
  function drawPickMarker(x,y,color,label){
    ctx.strokeStyle=color; ctx.fillStyle=color;
    ctx.beginPath(); ctx.moveTo(x,y-14); ctx.lineTo(x,y-2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x,y-2); ctx.lineTo(x-6,y-8); ctx.moveTo(x,y-2); ctx.lineTo(x+6,y-8); ctx.stroke();
    ctx.beginPath(); ctx.arc(x,y,4,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#000'; ctx.font='12px system-ui'; ctx.fillText(label, x+6, y-16);
  }
}

/* ---------- END ---------- */
</script>
</body>
</html>
